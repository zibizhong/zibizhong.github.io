<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>mysql</title><meta name="author" content="CodeZhong"><meta name="copyright" content="CodeZhong"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Mysql笔记Mysql架构了解mysql的安装目录windows中的目录  数据文件目录    1、bin目录 用于放置一些可执行文件，如mysql.exe、mysqld.exe、mysqlshow.exe等。 2、data目录 用于放置一些日志文件以及数据库。 3、include目录 用于放置一些头文件，如：mysql.h、mysql_ername.h等。 4、lib目录 用于放置一系列库文件">
<meta property="og:type" content="article">
<meta property="og:title" content="mysql">
<meta property="og:url" content="http://zibizhong.github.io/2022/09/01/mysql/index.html">
<meta property="og:site_name" content="CodeZhongBlog">
<meta property="og:description" content="Mysql笔记Mysql架构了解mysql的安装目录windows中的目录  数据文件目录    1、bin目录 用于放置一些可执行文件，如mysql.exe、mysqld.exe、mysqlshow.exe等。 2、data目录 用于放置一些日志文件以及数据库。 3、include目录 用于放置一些头文件，如：mysql.h、mysql_ername.h等。 4、lib目录 用于放置一系列库文件">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://zibizhong.github.io/images/background.jpg">
<meta property="article:published_time" content="2022-09-01T05:44:50.000Z">
<meta property="article:modified_time" content="2022-09-03T12:37:17.699Z">
<meta property="article:author" content="CodeZhong">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://zibizhong.github.io/images/background.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://zibizhong.github.io/2022/09/01/mysql/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":500},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: CodeZhong","link":"链接: ","source":"来源: CodeZhongBlog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://fastly.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://fastly.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'mysql',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-09-03 20:37:17'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/bgc.css"><meta name="generator" content="Hexo 6.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="is-center"><div class="avatar-img"><img src="/img/headImg.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">CodeZhong</div><div class="author-info__description"></div></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/zibizhong" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/2385172737@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-clock"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/artitalk"><i class="fa-fw fa fa-heartbeat"></i><span> 时光</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">CodeZhongBlog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-clock"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/artitalk"><i class="fa-fw fa fa-heartbeat"></i><span> 时光</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">mysql</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2022-09-01T05:44:50.000Z" title="发表于 2022-09-01 13:44:50">2022-09-01</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">30.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>103分钟</span></span></div></div></div><article class="post-content" id="article-container"><h1 id="Mysql笔记"><a href="#Mysql笔记" class="headerlink" title="Mysql笔记"></a>Mysql笔记</h1><h2 id="Mysql架构"><a href="#Mysql架构" class="headerlink" title="Mysql架构"></a>Mysql架构</h2><h3 id="了解mysql的安装目录"><a href="#了解mysql的安装目录" class="headerlink" title="了解mysql的安装目录"></a>了解mysql的安装目录</h3><h4 id="windows中的目录"><a href="#windows中的目录" class="headerlink" title="windows中的目录"></a>windows中的目录</h4><p><img src="/2022/09/01/mysql/image-20201201151814062.82ec67ba.png" alt="image-20201201151814062"></p>
<ul>
<li>数据文件目录</li>
</ul>
<p><img src="/2022/09/01/mysql/image-20201124143358592.e6ead470-166201151994410.png" alt="image-20201124143358592"></p>
<ul>
<li>1、<code>bin</code>目录</li>
<li>用于放置一些可执行文件，如mysql.exe、mysqld.exe、mysqlshow.exe等。</li>
<li>2、<code>data</code>目录</li>
<li>用于放置一些日志文件以及数据库。</li>
<li>3、<code>include</code>目录</li>
<li>用于放置一些头文件，如：mysql.h、mysql_ername.h等。</li>
<li>4、<code>lib</code>目录</li>
<li>用于放置一系列库文件。</li>
<li>5、<code>share</code>目录</li>
<li>用于存放字符集、语言等信息。</li>
<li>6、<code>my.ini</code>这个很重要</li>
<li>是MySQL数据库中使用的配置文件。</li>
</ul>
<p>配置文件很重要，所谓配置文件就是配置一下你的mysql让他成为你想要的的样子。</p>
<h4 id="linux中的文件目录"><a href="#linux中的文件目录" class="headerlink" title="linux中的文件目录"></a>linux中的文件目录</h4><p>咱们当时使用的是rpm安装，他会有个默认的路径。</p>
<ul>
<li>bin目录</li>
</ul>
<p><img src="/2022/09/01/mysql/image-20201124144036825.f6083823-16620115199439.png" alt="image-20201124144036825"></p>
<ul>
<li>配置文件</li>
</ul>
<p><img src="/2022/09/01/mysql/image-20201124144308513.1edc6745.png" alt="image-20201124144308513"></p>
<ul>
<li>pid文件</li>
</ul>
<p>这个文件用来指导当前运行的mysql实例的进程号！</p>
<p><img src="/2022/09/01/mysql/image-20201124145129705.3d57ca1b-166201151994411.png" alt="image-20201124145129705"></p>
<ul>
<li>数据库文件</li>
</ul>
<p><img src="/2022/09/01/mysql/image-20201124145235600.2b47a32d.png" alt="image-20201124145235600"></p>
<h4 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h4><ul>
<li>port：端口</li>
<li>server-id：数据库唯一标识码</li>
<li>datadir：数据目录路径</li>
<li>basedir：基本路径</li>
<li>socket：指定socket文件路径</li>
<li>skip-name-resolve：禁止mysql对外部连接进行DNS解析，启用时所有远程连接都要使用ip地址方式</li>
<li>skip-external-locking：避免外部锁，默认开启</li>
<li>skip-grant-tables：mysql启动时不使用grant-tables授权表，常用于忘记密码情况下</li>
<li>user：使用的用户</li>
<li>sql_mode：约束SQL语法模式</li>
<li>show_query_log_file：慢日志存储路径，5.6及以上版本，log-slow-queries是5.6以下版本</li>
<li>long_query_time：设置慢查询时间，默认10s</li>
<li>log-queries-not-using-indexes：记录未使用索引查询</li>
<li>log_throttle_queries_not_using_indexs：5.6.5版本新增参数，设定每分钟记录到日志未使用索引的语句数目，超过则之后只记录语句数量和花费总时间</li>
<li>log_output：日志存储方式，默认FILE，TABLE表示写入到mysql.slow_log表</li>
<li>expire_logs_days：二进制日志保留的时间</li>
<li>log-bin：设置日志文件路径及名称</li>
<li>log-bin-index：日志文件后缀形式</li>
<li>relay-bin：中继日志文件</li>
<li>relay-bin-index：中继日志文件后缀形式</li>
<li>max_connections：mysql最大连接数（超出会报Too many connections）</li>
<li>back_log：mysql暂存的连接数量(每个连接占用256kb)</li>
<li>wait_timeout：关闭一个非交互的连接之前所需要等待的秒数</li>
<li>max_connect_errors：最大错误连接数，flush host进行解禁</li>
<li>max_allowed_packet：接受数据包大小，需要是才会分配内存，设置过大会造成内存溢出</li>
<li>max_heap_table_size：用户可以创建的内存表大小</li>
<li>tmp_table_size：mysql的heap表缓冲大小</li>
<li>read_rnd_buffer_size：mysql随机读缓冲区大小</li>
<li>sort_buffer_size：mysql执行排序使用的缓冲大小</li>
<li>join_buffer_size：联合查询操作所能使用的缓冲区大小</li>
</ul>
<h4 id="mysql修改配置的方法mysql修改配置的方法"><a href="#mysql修改配置的方法mysql修改配置的方法" class="headerlink" title="mysql修改配置的方法mysql修改配置的方法"></a>mysql修改配置的方法mysql修改配置的方法</h4><p>（1）设置全局变量方法1(不推荐): 修改参数文件, 然后重启mysqld</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># vi /etc/my.cnf</span><br><span class="line">[mysqld]</span><br><span class="line">wait_timeout=10</span><br><span class="line"># service mysqld restart</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4</p>
<p>不过这个方法太生硬了, 线上服务重启无论如何都应该尽可能避免.</p>
<p>（2）设置全局变量方法2(推荐): 在命令行里通过SET来设置, 然后再修改参数文件**</p>
<p>如果要修改全局变量, 必须要显示指定”GLOBAL”或者”@@global.”, 同时必须要有SUPER权限.</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set global wait_timeout=10;</span><br><span class="line">mysql&gt; set @@global.wait_timeout=10;</span><br></pre></td></tr></table></figure>

<p>1<br>2</p>
<p>然后查看设置是否成功:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select @@global.wait_timeout=10;</span><br><span class="line">or</span><br><span class="line">mysql&gt; show global variables like &#x27;wait_timeout&#x27;;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3</p>
<p>如果查询时使用的是show variables的话, 会发现设置并没有生效, 除非重新登录再查看. 这是因为使用show variables的话就等同于使用show session variables, 查询的是会话变量, 只有使用show global variables查询的才是全局变量. 如果仅仅想修改会话变量的话, 可以使用类似set wait_timeout&#x3D;10;或者set session wait_timeout&#x3D;10;这样的语法.</p>
<p>当前只修改了正在运行的MySQL实例参数, 但下次重启mysqld又会回到默认值, 所以别忘了修改参数文件:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># vi /etc/my.cnf</span><br><span class="line">[mysqld]</span><br><span class="line">wait_timeout=10</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3</p>
<p>（3）设置会话变量方法: 在命令行里通过SET来设置</p>
<p>如果要修改会话变量值, 可以指定”SESSION”或者”@@session.”或者”@@”或者”LOCAL”或者”@@local.”, 或者什么都不使用.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> wait_timeout<span class="operator">=</span><span class="number">10</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> session wait_timeout<span class="operator">=</span><span class="number">10</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> <span class="keyword">local</span> wait_timeout<span class="operator">=</span><span class="number">10</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> @<span class="variable">@wait</span>_timeout<span class="operator">=</span><span class="number">10</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> @<span class="variable">@session</span>.wait_timeout<span class="operator">=</span><span class="number">10</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> @<span class="variable">@local</span>.wait_timeout<span class="operator">=</span><span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6</p>
<p>然后查看设置是否成功:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> @<span class="variable">@wait</span>_timeout;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> @<span class="variable">@session</span>.wait_timeout;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> @<span class="variable">@local</span>.wait_timeout;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;wait_timeout&#x27;</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">local</span> variables <span class="keyword">like</span> <span class="string">&#x27;wait_timeout&#x27;</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> session variables <span class="keyword">like</span> <span class="string">&#x27;wait_timeout&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6</p>
<p>（4）会话变量和全局变量转换方法:</p>
<p>在命令行里通过SET来设置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将会话变量值设置为对应的全局变量值呢:</span></span><br><span class="line">mysql&gt; <span class="built_in">set</span> @@session.wait_timeout=@@global.wait_timeout;</span><br><span class="line"><span class="comment"># 将会话变量值设置为MySQL编译时的默认值(wait_timeout=28800):</span></span><br><span class="line">mysql&gt; <span class="built_in">set</span> wait_timeout=DEFAULT;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4</p>
<p>这里要注意的是, 并不是所有的系统变量都能被设置为DEFAULT, 如果设置这些变量为DEFAULT则会返回错误.</p>
<h3 id="mysql的系统架构"><a href="#mysql的系统架构" class="headerlink" title="mysql的系统架构"></a>mysql的系统架构</h3><h4 id="1、-数据库和数据库实例"><a href="#1、-数据库和数据库实例" class="headerlink" title="1、 数据库和数据库实例"></a>1、 数据库和数据库实例</h4><p>在MySQL的学习研究中，存在两个非常容易混淆的概念，即<code>数据库</code>和<code>数据库实例</code>。在MySQL中，数据库和数据库实例定义如下：</p>
<ul>
<li>数据库：存储数据的；</li>
<li>数据库实例：操作数据库的。</li>
</ul>
<p>如上定义很清楚了，数据库是用来存储数据的，数据库实例是用来操作数据的，从操作系统的角度，数据库实例表现为一个进程，对应多个线程，</p>
<p>在非集群数据库架构中，数据库与数据库实例存在一 一对应关系，在数据库集群中，可能存在多个数据库实例操作一个数据库情况，即多对一关系。</p>
<h4 id="MySQL架构"><a href="#MySQL架构" class="headerlink" title="MySQL架构"></a>MySQL架构</h4><p>复杂的架构是为了更好的工作，架构中的每一个角色都可以高效的单独处理一类事件，举个例子。</p>
<p>你去拜访你朋友当然朋友自己迎接你即可。</p>
<p>但是你要拜访市长，可能就要门卫处做身份认证、传达室负责接通电话确认可以、市长办公室负责接待、你可能需要排队等候、你的事情如果办公室就能解决可能就不用见市长了，最后轮到你了，你才能见上市长。</p>
<p>对于MySQL来说，虽然经历了多个版本迭代（MySQL5.5,MySQL 5.6,MySQL 5.7,MySQL 8）,但每次的迭代，都是基于MySQL</p>
<p>基架的，MySQL基架大致包括如下几大模块组件：</p>
<p><strong>（1）MySQL向外提供的交互接口（Connectors）</strong></p>
<p>Connectors组件，是MySQL向外提供的交互组件，如java,.net,php等语言可以通过该组件来操作SQL语句，实现与SQL的交互。</p>
<p><strong>（2）管理服务组件和工具组件(Management Service &amp; Utilities)</strong></p>
<p>提供对MySQL的集成管理，如备份(Backup),恢复(Recovery),安全管理(Security)等</p>
<p><strong>（3）连接池组件(Connection Pool)</strong></p>
<p>负责监听对客户端向MySQL Server端的各种请求，接收请求，转发请求到目标模块。每个成功连接MySQL Server的客户请求都会被</p>
<p>创建或分配一个线程，该线程负责客户端与MySQL Server端的通信，接收客户端发送的命令，传递服务端的结果信息等。</p>
<p><strong>（4）SQL接口组件(SQL Interface)</strong></p>
<p>接收用户SQL命令，如DML,DDL和存储过程等，并将最终结果返回给用户。</p>
<p><strong>（5）查询分析器组件(Parser)</strong></p>
<p>首先分析SQL命令语法的合法性，并尝试将SQL命令分解成数据结构，若分解失败，则提示SQL语句不合理。</p>
<p><strong>（6）优化器组件（Optimizer）</strong></p>
<p>对SQL命令按照标准流程进行优化分析。</p>
<p><strong>（7）缓存主件（Caches &amp; Buffers）</strong></p>
<p>缓存和缓冲组件</p>
<p><img src="/2022/09/01/mysql/image-20201208160336839.6d0236a8.png" alt="image-20201208160336839"></p>
<p><img src="/2022/09/01/mysql/image-20201208160226331.a43090d0.png" alt="image-20201208160226331"></p>
<p><strong>（8）MySQL存储引擎</strong></p>
<blockquote>
<p>什么是MySQL存储引擎</p>
</blockquote>
<p> MySQL属于关系型数据库，而关系型数据库的存储是以表的形式进行的，对于表的创建，数据的存储，检索，更新等都是由MySQL</p>
<p>存储引擎完成的，这也是MySQL存储引擎在MySQL中扮演的重要角色。</p>
<p> 研究过SQL Server和Oracle的读者可能很清楚，这两种数据库的存储引擎只有一个，而MySQL的存储引擎种类比较多，如MyISAM存储引擎，InnoDB存储引擎和Memory存储引擎.</p>
<p> MySQL之所以有多种存储引擎，是因为MySQL的开源性决定的。MySQL存储引擎，从种类上来说，大致可归结为官方存储引擎和第三方存储引起。MySQL的开源性，允许第三方基于MySQL骨架，开发适合自己业务需求的存储引擎。</p>
<blockquote>
<p>MySQL存储引擎作用</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MySQL存储引擎在MySQL中扮演重要角色，其作比较重要作用，大致归结为如下两方面：</span><br></pre></td></tr></table></figure>

<p> 作用一：管理表创建，数据检索，索引创建等</p>
<p> 作用二：满足自定义存储引擎开发。</p>
<blockquote>
<p>MySQL引擎种类</p>
</blockquote>
<p> 不同种类的存储引擎，在存储表时的存储引擎表机制也有所不同，从MySQL存储引擎种类上来说，可以分为官方存储引擎和第三方存储引擎。</p>
<p> 比较常用的存储引擎包括InnoDB存储引擎，MyISAM存储引擎和Momery存储引擎。</p>
<p>（九）物理文件（File System）</p>
<p>实际存储<code>MySQL 数据库文件</code>和一些<code>日志文件</code>等的系统。</p>
<h3 id="mysql的存储引擎"><a href="#mysql的存储引擎" class="headerlink" title="mysql的存储引擎"></a>mysql的存储引擎</h3><blockquote>
<p>能看懂多少看多少，以后会一点点了解</p>
</blockquote>
<h3 id="MySQL常用存储引擎及特点"><a href="#MySQL常用存储引擎及特点" class="headerlink" title="MySQL常用存储引擎及特点"></a>MySQL常用存储引擎及特点</h3><h4 id="InnoDB存储引擎"><a href="#InnoDB存储引擎" class="headerlink" title="InnoDB存储引擎"></a>InnoDB存储引擎</h4><p>从MySQL5.5版本之后，MySQL的默认内置存储引擎已经是InnoDB了，他的主要特点有：</p>
<p>（1）支持事务。默认的事务隔离级别为可重复度，通过MVCC（并发版本控制）来实现的。 （2）使用的锁粒度为行级锁，可以支持更高的并发； （3）支持外键； （4）在InnoDB中存在着缓冲管理，通过缓冲池，将索引和数据全部缓存起来，加快查询的速度； （5）对于InnoDB类型的表，其数据的物理组织形式是聚簇表。所有的数据按照主键来组织。数据和索引放在一块，都位于B+数的叶子节点上；</p>
<h4 id="MyISAM存储引擎"><a href="#MyISAM存储引擎" class="headerlink" title="MyISAM存储引擎"></a>MyISAM存储引擎</h4><p>在5.5版本之前，MyISAM是MySQL的默认存储引擎，该存储引擎并发性差，不支持事务，所以使用场景比较少，主要特点为：</p>
<p>（1）不支持事务； （2）不支持外键，如果强行增加外键，不会提示错误，只是外键不其作用； （3）对数据的查询缓存只会缓存索引，不会像InnoDB一样缓存数据，而且是利用操作系统本身的缓存； （4）默认的锁粒度为表级锁，所以并发度很差，加锁快，锁冲突较少，所以不太容易发生死锁； （5）支持全文索引（MySQL5.6之后，InnoDB存储引擎也对全文索引做了支持），但是MySQL的全文索引基本不会使用，对于全文索引，现在有其他成熟的解决方案，比如：ElasticSearch，Solr，Sphinx等。 （6）数据库所在主机如果宕机，MyISAM的数据文件容易损坏，而且难恢复；</p>
<h4 id="两种引擎的对比"><a href="#两种引擎的对比" class="headerlink" title="两种引擎的对比"></a>两种引擎的对比</h4><p>1、由于锁粒度的不同，InnoDB比MyISAM支持更高的并发；</p>
<p> 2、InnoDB为行级锁，MyISAM为表级锁，所以InnoDB相对于MyISAM来说，更容易发生死锁，锁冲突的概率更大，而且上锁的开销也更大，因为需要为每一行加锁； </p>
<p>3、在备份容灾上，InnoDB支持在线热备，有很成熟的在线热备解决方案；</p>
<p> 4、查询性能上，MyISAM的查询效率高于InnoDB，因为InnoDB在查询过程中，是需要维护数据缓存，而且查询过程是先定位到行所在的数据块，然后在从数据块中定位到要查找的行；而MyISAM可以直接定位到数据所在的内存地址，可以直接找到数据； </p>
<p>5、SELECT COUNT(*)语句，如果行数在千万级别以上，MyISAM可以快速查出，而InnoDB查询的特别慢，因为MyISAM将行数单独存储了，而InnoDB需要逐行去统计行数；所以如果使用InnoDB，而且需要查询行数，则需要对行数进行特殊处理，如：离线查询并缓存； </p>
<p>6、MyISAM的表结构文件包括：.frm(表结构定义),.MYI(索引),.MYD(数据)；而InnoDB的表数据文件为:.ibd和.frm(表结构定义)；</p>
<h4 id="选择合适的存储引擎"><a href="#选择合适的存储引擎" class="headerlink" title="选择合适的存储引擎"></a>选择合适的存储引擎</h4><p>1、使用场景是否需要事务支持； </p>
<p>2、是否需要支持高并发，InnoDB的并发度远高于MyISAM；</p>
<p> 3、是否需要支持外键；</p>
<p> 4、高效缓冲数据，InnoDB对数据和索引都做了缓冲，而MyISAM只缓冲了索引；</p>
<p> 5、索引，不同存储引擎的索引并不太一样；</p>
<h2 id="Mysql索引"><a href="#Mysql索引" class="headerlink" title="Mysql索引"></a>Mysql索引</h2><h4 id="计算机硬盘原理"><a href="#计算机硬盘原理" class="headerlink" title="计算机硬盘原理"></a>计算机硬盘原理</h4><h5 id="磁盘IO的问题"><a href="#磁盘IO的问题" class="headerlink" title="磁盘IO的问题"></a>磁盘IO的问题</h5><p>mysql的数据一般以文件形式存储在磁盘上，检索需要磁盘I&#x2F;O操作。与主存不同，磁盘I&#x2F;O存在机械运动耗费，因此磁盘I&#x2F;O的时间消耗是巨大的。</p>
<p><img src="/2022/09/01/mysql/image-20201122150129276.837e618f.png" alt="image-20201122150129276"></p>
<h5 id="磁盘的一些概念"><a href="#磁盘的一些概念" class="headerlink" title="磁盘的一些概念"></a>磁盘的一些概念</h5><ol>
<li>盘片、片面 和 磁头</li>
</ol>
<p>硬盘中一般会有多个盘片组成，每个盘片包含两个面，每个盘面都对应地有一个读&#x2F;写磁头。受到硬盘整体体积和生产成本的限制，盘片数量都受到限制，一般都在5片以内。盘片的编号自下向上从0开始，如最下边的盘片有0面和1面，再上一个盘片就编号为2面和3面。 如下图：</p>
<p><img src="/2022/09/01/mysql/image-20211220185623160.549dea9c.png" alt="image-20211220185623160"></p>
<ol start="2">
<li>扇区 和 磁道</li>
</ol>
<p>下图显示的是一个盘面，盘面中一圈圈灰色同心圆为一条条磁道，从圆心向外画直线，可以将磁道划分为若干个弧段，每个磁道上一个弧段被称之为一个扇区（图践绿色部分）。扇区是磁盘的最小组成单元，通常是512字节。（由于不断提高磁盘的大小，部分厂商设定每个扇区的大小是4096字节）</p>
<p><img src="/2022/09/01/mysql/image-20211220185637275.3aa075f8-166201207344456.png" alt="image-20211220185637275"></p>
<ol start="3">
<li>磁头-和-磁头 和 柱面</li>
</ol>
<p>硬盘通常由重叠的一组盘片构成，每个盘面都被划分为数目相等的磁道，并从外缘的“0”开始编号，具有相同编号的磁道形成一个圆柱，称之为磁盘的柱面。磁盘的柱面数与一个盘面上的磁道数是相等的。由于每个盘面都有自己的磁头，因此，盘面数等于总的磁头数。 如下图</p>
<p><img src="/2022/09/01/mysql/image-20211220185702150.91f610d6-166201207344457.png" alt="image-20211220185702150"></p>
<p>图3</p>
<h5 id="磁盘容量计算"><a href="#磁盘容量计算" class="headerlink" title="磁盘容量计算"></a>磁盘容量计算</h5><p>存储容量 ＝ 磁头数 × 磁道(柱面)数 × 每道扇区数 × 每扇区字节数</p>
<p>图3中磁盘是一个 3个圆盘6个磁头，7个柱面（每个盘片7个磁道） 的磁盘，图3中每条磁道有12个扇区，所以此磁盘的容量为：</p>
<p>存储容量 6 * 7 * 12 * 512 &#x3D; 258048</p>
<blockquote>
<p>每个磁道的扇区数一样是说的老的硬盘，外圈的密度小，内圈的密度大，每圈可存储的数据量是一样的。新的硬盘数据的密度都一致，这样磁道的周长越长，扇区就越多，存储的数据量就越大。</p>
</blockquote>
<h5 id="磁盘读取响应时间"><a href="#磁盘读取响应时间" class="headerlink" title="磁盘读取响应时间"></a>磁盘读取响应时间</h5><ol>
<li>寻道时间：磁头从开始移动到数据所在磁道所需要的时间，寻道时间越短，I&#x2F;O操作越快，目前磁盘的平均寻道时间一般在3－15ms，一般都在10ms左右。</li>
<li>旋转延迟：盘片旋转将请求数据所在扇区移至读写磁头下方所需要的时间，旋转延迟取决于磁盘转速。普通硬盘一般都是7200rpm，慢的5400rpm。</li>
<li>数据传输时间：完成传输所请求的数据所需要的时间。 小结一下：从上面的指标来看、其实最重要的、或者说、我们最关心的应该只有两个：寻道时间；旋转延迟。</li>
</ol>
<blockquote>
<p>读写一次磁盘信息所需的时间可分解为：寻道时间、延迟时间、传输时间。为提高磁盘传输效率，软件应着重考虑减少寻道时间和延迟时间。</p>
</blockquote>
<h5 id="块-x2F-簇"><a href="#块-x2F-簇" class="headerlink" title="块&#x2F;簇"></a>块&#x2F;簇</h5><p>磁盘块&#x2F;簇（虚拟出来的）。 块是操作系统中最小的逻辑存储单位。操作系统与磁盘打交道的最小单位是磁盘块。每个块可以包括2、4、8、16、32、64…2的n次方个扇区。</p>
<blockquote>
<p>为什么存在磁盘块？</p>
</blockquote>
<p>读取方便：由于扇区的数量比较小，数目众多在寻址时比较困难，所以操作系统就将相邻的扇区组合在一起，形成一个块，再对块进行整体的操作。</p>
<p>分离对底层的依赖：操作系统忽略对底层物理存储结构的设计。通过虚拟出来磁盘块的概念，在系统中认为块是最小的单位。</p>
<h5 id="page"><a href="#page" class="headerlink" title="page"></a>page</h5><p>操作系统经常与内存和硬盘这两种存储设备进行通信，类似于“块”的概念，都需要一种虚拟的基本单位。所以，与内存操作，是虚拟一个页的概念来作为最小单位。与硬盘打交道，就是以块为最小单位。</p>
<h5 id="扇区、块-x2F-簇、page的关系"><a href="#扇区、块-x2F-簇、page的关系" class="headerlink" title="扇区、块&#x2F;簇、page的关系"></a>扇区、块&#x2F;簇、page的关系</h5><ol>
<li>扇区： 硬盘的最小读写单元</li>
<li>块&#x2F;簇： 是操作系统针对硬盘读写的最小单元</li>
<li>page： 是内存与操作系统之间操作的最小单元。</li>
</ol>
<p>扇区 &lt;&#x3D; 块&#x2F;簇 &lt;&#x3D; page</p>
<h5 id="计算机读取数据流程"><a href="#计算机读取数据流程" class="headerlink" title="计算机读取数据流程"></a>计算机读取数据流程</h5><p> 当需要从磁盘读取数据时，系统会将数据地址传给磁盘，即确定要读的数据在哪个磁道，哪个扇区。为了读取这个扇区的数据，需要将磁头放到这个扇区上方，为了实现这一点，磁头需要移动对准相应磁道，这个过程叫做<code>寻道</code>，所耗费时间叫做<code>寻道时间</code>，然后磁盘旋转将目标扇区旋转到磁头下，这个过程耗费的时间叫做<strong>旋转时间</strong>。</p>
<h5 id="局部性原理与磁盘预读"><a href="#局部性原理与磁盘预读" class="headerlink" title="局部性原理与磁盘预读"></a>局部性原理与磁盘预读</h5><p> 由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的十万分之一，因此为了提高效率，要<strong>尽量减少磁盘I&#x2F;O</strong>。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的<strong>局部性原理</strong>：</p>
<p> 当一个数据被用到时，其附近的数据也通常会马上被使用。</p>
<p> 程序运行期间所需要的数据通常比较集中。</p>
<p> 由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I&#x2F;O效率。</p>
<p> 预读的长度一般为<strong>页（page）</strong>的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p>
<p>下图是计算机硬件延迟的对比图，供大家参考：</p>
<p><img src="/2022/09/01/mysql/image-20211220185718788.4f28688a-166201207344458.png" alt="image-20211220185718788"></p>
<h4 id="mysql数据结构的选型"><a href="#mysql数据结构的选型" class="headerlink" title="mysql数据结构的选型"></a>mysql数据结构的选型</h4><p>从第一块内容中我们明白了磁盘是怎么存储文件的，而我们的mysql的数据文件又是存储在磁盘上的，所以我们有必要去研究一下，mysql是怎么保障数据在磁盘上存储，效率还能比较高的原因。</p>
<p>首先，在数据库文件存储在磁盘时，为了提升查询效率，一定会选用合适的数据结构进行文件的存储。接下来咱们探讨一下：</p>
<h5 id="数组和链表"><a href="#数组和链表" class="headerlink" title="数组和链表"></a>数组和链表</h5><p>肯定不能选，这种最基本的数据结构，各自的劣势太明显。</p>
<p>数据库对查询要求是最很高的所以链表这种查询必须全表遍历的基本数据结构是不能用的。</p>
<p>数组这种结构在添加数据时成本太大，插入数据时太过于频繁。</p>
<h5 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h5><p>类似与咱们的hashmap，这样行吗？ 速度快，但是只要是hash就会产生无序的问题，所以不常用但也有。</p>
<h5 id="树"><a href="#树" class="headerlink" title="树"></a>树</h5><p>看来看去也就是树这种结构比较合理了。</p>
<p>二叉查找树可以吗？</p>
<p>在查找一个数据时，二叉树是读取根节点，小则从左找，大则从右找，每次读取一个数据。没有办法合理的利用局部性原理与磁盘预读，IO次数太多太多，其次就是树的层次还是偏高，所以不适合。</p>
<p>那每次读多个数据，每一个节点存多个数据的结构就只有B-树和B+树了；</p>
<p>接下来就讨论这两种数据结构的选型。</p>
<h5 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h5><p>B-树,这里的 B 表示 balance( 平衡的意思),B-树是一种多路自平衡的搜索树 它类似普通的平衡二叉树，不同的一点是B-树允许每个节点有更多的子节点。下图是 B-树的简化图.</p>
<p><img src="/2022/09/01/mysql/image-20211220185730764.23e36eec-166201207344459.png" alt="image-20211220185730764"></p>
<p>B-树有如下特点:</p>
<ol>
<li>所有键值分布在整颗树中；</li>
<li>任何一个关键字出现且只出现在一个结点中；</li>
<li>搜索有可能在非叶子结点结束；</li>
<li>在关键字全集内做一次查找,性能逼近二分查找；</li>
</ol>
<h5 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+ 树"></a>B+ 树</h5><p>默认是主键，如果没有主键则使用唯一索引，唯一索引也没有则使用rowid，行号。</p>
<p>所以一定要建立主键。</p>
<p>B+树是B-树的变体，也是一种多路搜索树, 它与 B- 树的不同之处在于:</p>
<ol>
<li>所有关键字存储在叶子节点出现,内部节点(非叶子节点并不存储真正的 data)</li>
<li>为所有叶子结点增加了一个链指针</li>
</ol>
<p>简化 B+树 如下图</p>
<p><img src="/2022/09/01/mysql/image-20211220185740972.ff0c4b5b-166201207344460.png" alt="image-20211220185740972"></p>
<h5 id="为什么使用-B-树"><a href="#为什么使用-B-树" class="headerlink" title="为什么使用 B+树"></a>为什么使用 B+树</h5><ol>
<li>相对于 B 树 非叶子节点 没有数据， 一个页就能存更多的id， 可以大大减小层级。   每个节点能节点的范围更大更精确,I&#x2F;O效率更高。</li>
<li>Mysql是一种关系型数据库，区间访问是常见的一种情况，B+树叶节点增加的链指针,加强了区间访问性，可使用在范围区间查询等。</li>
</ol>
<p>  参考网上的回答：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/Candycan/p/14810842.html">数据库索引——B+树索引（为什么使用B+树作为MySql的索引结构，用什么好处？） - your_棒棒糖 - 博客园 (cnblogs.com)</a></p>
<h4 id="为什么要使用索引"><a href="#为什么要使用索引" class="headerlink" title="为什么要使用索引"></a>为什么要使用索引</h4><p>1、mysql的数据是存在磁盘上的，磁盘的读取速度是比较慢的使用主键的读取方式会很快，当数据来那个太大非主键的字段查询是会特别耗时。一条语句可能查询10秒以上。</p>
<p>2、建立在主键上的B+树结构可以快速查询出咱们的数据，那使用其他字段就一定要这么慢吗？</p>
<h4 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h4><h5 id="索引的数据结构-1"><a href="#索引的数据结构-1" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h5><p><img src="/2022/09/01/mysql/image-20211220185740972.ff0c4b5b-166201207344460.png" alt="image-20211220185740972"></p>
<p>最顶层的叶子节点为常驻内存，这样旧可以减少一次io</p>
<p>在数据库中，B+Tree的高度一般都在2<del>4层。mysql的innoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1</del>3次磁盘I&#x2F;O操作。</p>
<h5 id="有了索引怎么查询"><a href="#有了索引怎么查询" class="headerlink" title="有了索引怎么查询"></a>有了索引怎么查询</h5><ul>
<li>从索引里自上而下查询</li>
<li>走到叶子节点查询到id</li>
<li>根据id去聚簇索引中查找真正的数据，这个过程叫做<code>回表</code></li>
<li>如果你要的数据索引都有了不需要回表，就叫<code>索引覆盖</code>。</li>
</ul>
<h4 id="索引的分类和创建"><a href="#索引的分类和创建" class="headerlink" title="索引的分类和创建"></a>索引的分类和创建</h4><blockquote>
<p>索引的命名</p>
</blockquote>
<p>普通索引：idx_字段名</p>
<p>唯一索引：ux_字段名</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 学科表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> subject(</span><br><span class="line"> id <span class="type">int</span>(<span class="number">10</span>) auto_increment,</span><br><span class="line"> name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line"> teacher_id <span class="type">int</span>(<span class="number">10</span>),</span><br><span class="line"> <span class="keyword">primary</span> key (id),</span><br><span class="line"> index idx_teacher_id (teacher_id));</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 教师表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> teacher(</span><br><span class="line"> id <span class="type">int</span>(<span class="number">10</span>) auto_increment,</span><br><span class="line"> name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line"> teacher_no <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line"> <span class="keyword">primary</span> key (id),</span><br><span class="line"> <span class="keyword">unique</span> index unx_teacher_no (teacher_no(<span class="number">20</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 学生表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student(</span><br><span class="line"> id <span class="type">int</span>(<span class="number">10</span>) auto_increment,</span><br><span class="line"> name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line"> student_no <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line"> <span class="keyword">primary</span> key (id),</span><br><span class="line"> <span class="keyword">unique</span> index unx_student_no (student_no(<span class="number">20</span>)));</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 学生成绩表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student_score(</span><br><span class="line"> id <span class="type">int</span>(<span class="number">10</span>) auto_increment,</span><br><span class="line"> student_id <span class="type">int</span>(<span class="number">10</span>),</span><br><span class="line"> subject_id <span class="type">int</span>(<span class="number">10</span>),</span><br><span class="line"> score <span class="type">int</span>(<span class="number">10</span>),</span><br><span class="line"> <span class="keyword">primary</span> key (id),</span><br><span class="line"> index idx_student_id (student_id),</span><br><span class="line"> index idx_subject_id (subject_id));</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 教师表增加名字普通索引 </span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> teacher <span class="keyword">add</span> index idx_name(name(<span class="number">20</span>));</span><br><span class="line"> </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student(name,student_no) <span class="keyword">values</span> (<span class="string">&#x27;zhangsan&#x27;</span>,<span class="string">&#x27;20200001&#x27;</span>),(<span class="string">&#x27;lisi&#x27;</span>,<span class="string">&#x27;20200002&#x27;</span>),(<span class="string">&#x27;yan&#x27;</span>,<span class="string">&#x27;20200003&#x27;</span>),(<span class="string">&#x27;dede&#x27;</span>,<span class="string">&#x27;20200004&#x27;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> teacher(name,teacher_no) <span class="keyword">values</span>(<span class="string">&#x27;wangsi&#x27;</span>,<span class="string">&#x27;T2010001&#x27;</span>),(<span class="string">&#x27;sunsi&#x27;</span>,<span class="string">&#x27;T2010002&#x27;</span>),(<span class="string">&#x27;jiangsi&#x27;</span>,<span class="string">&#x27;T2010003&#x27;</span>),(<span class="string">&#x27;zhousi&#x27;</span>,<span class="string">&#x27;T2010004&#x27;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> subject(name,teacher_id) <span class="keyword">values</span>(<span class="string">&#x27;math&#x27;</span>,<span class="number">1</span>),(<span class="string">&#x27;Chinese&#x27;</span>,<span class="number">2</span>),(<span class="string">&#x27;English&#x27;</span>,<span class="number">3</span>),(<span class="string">&#x27;history&#x27;</span>,<span class="number">4</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student_score(student_id,subject_id,score) <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">90</span>),(<span class="number">1</span>,<span class="number">2</span>,<span class="number">60</span>),(<span class="number">1</span>,<span class="number">3</span>,<span class="number">80</span>),(<span class="number">1</span>,<span class="number">4</span>,<span class="number">100</span>),(<span class="number">2</span>,<span class="number">4</span>,<span class="number">60</span>),(<span class="number">2</span>,<span class="number">3</span>,<span class="number">50</span>),(<span class="number">2</span>,<span class="number">2</span>,<span class="number">80</span>),(<span class="number">2</span>,<span class="number">1</span>,<span class="number">90</span>),(<span class="number">3</span>,<span class="number">1</span>,<span class="number">90</span>),(<span class="number">3</span>,<span class="number">4</span>,<span class="number">100</span>),(<span class="number">4</span>,<span class="number">1</span>,<span class="number">40</span>),(<span class="number">4</span>,<span class="number">2</span>,<span class="number">80</span>),(<span class="number">4</span>,<span class="number">3</span>,<span class="number">80</span>),(<span class="number">4</span>,<span class="number">5</span>,<span class="number">100</span>);</span><br></pre></td></tr></table></figure>



<h5 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h5><p><img src="/2022/09/01/mysql/image-20201122163422044.3237ed38.png" alt="image-20201122163422044"></p>
<ol>
<li>InnoDB使用的是聚簇索引，将主键组织到一棵B+树中，而行数据就储存在叶子节点上，若使用”where id &#x3D; 14”这样的条件查找主键，则按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据。</li>
<li>若对Name列进行条件搜索，则需要两个步骤：第一步在辅助索引B+树中检索Name，到达其叶子节点获取对应的主键。第二步使用主键在主索引B+树种再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据。（重点在于通过其他键需要建立辅助索引）</li>
</ol>
<p><strong>聚簇索引具有唯一性</strong>，由于聚簇索引是将数据跟索引结构放到一块，因此一个表仅有一个聚簇索引。</p>
<p><strong>表中行的物理顺序和索引中行的物理顺序是相同的</strong>，在创建任何非聚簇索引之前创建聚簇索引，这是因为聚簇索引改变了表中行的物理顺序，数据行 按照一定的顺序排列，并且自动维护这个顺序；</p>
<p><strong>聚簇索引默认是主键</strong>，如果表中没有定义主键，InnoDB 会选择一个唯一且非空的索引代替。如果没有这样的索引，InnoDB 会隐式定义一个主键（类似oracle中的RowId）来作为聚簇索引。如果已经设置了主键为聚簇索引又希望再单独设置聚簇索引，必须先删除主键，然后添加我们想要的聚簇索引，最后恢复设置主键即可。</p>
<p><strong>MyISAM使用的是非聚簇索引，</strong>非聚簇索引的两棵B+树看上去没什么不同，节点的结构完全一致只是存储的内容不同而已，主键索引B+树的节点存储了主键，辅助键索引B+树存储了辅助键。表数据存储在独立的地方，这两颗B+树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别。由于索引树是独立的，通过辅助键检索无需访问主键的索引树。</p>
<h6 id="使用聚簇索引的优势："><a href="#使用聚簇索引的优势：" class="headerlink" title="使用聚簇索引的优势："></a>使用聚簇索引的优势：</h6><p>1.由于行数据和聚簇索引的叶子节点存储在一起，同一页中会有多条行数据，访问同一数据页不同行记录时，已经把页加载到了Buffer中（缓存器），再次访问时，会在内存中完成访问，不必访问磁盘。这样主键和行数据是一起被载入内存的，找到叶子节点就可以立刻将行数据返回了，如果按照主键Id来组织数据，获得数据更快。</p>
<p><strong>自己的理解</strong>： 访问一页时，加载了行数据。。。例如查询2.。。。返回了1,2,3,4行数据。。后面再查3，就可以立马在缓存区拿到，而不用进入磁盘。。。但是 非聚集索引，只是记录了地址信息，没有排序，无法拿到附近的数据。</p>
<p>2.辅助索引的叶子节点，存储主键值，而不是数据的存放地址。好处是当行数据放生变化时，索引树的节点也需要分裂变化；或者是我们需要查找的数据，在上一次IO读写的缓存中没有，需要发生一次新的IO操作时，可以避免对辅助索引的维护工作，只需要维护聚簇索引树就好了。另一个好处是，因为辅助索引存放的是主键值，减少了辅助索引占用的存储空间大小。</p>
<p><strong>自己的理解</strong>，比如增删改，为了维护节点会造成地址变化。</p>
<p>注：我们知道一次io读写，可以获取到16K大小的资源，我们称之为读取到的数据区域为Page。而我们的B树，B+树的索引结构，叶子节点上存放好多个关键字（索引值）和对应的数据，都会在一次IO操作中被读取到缓存中，所以在访问同一个页中的不同记录时，会在内存里操作，而不用再次进行IO操作了。除非发生了页的分裂，即要查询的行数据不在上次IO操作的换村里，才会触发新的IO操作。</p>
<p>3.因为MyISAM的主索引并非聚簇索引，那么他的数据的物理地址必然是凌乱的，拿到这些物理地址，按照合适的算法进行I&#x2F;O读取，于是开始不停的寻道不停的旋转。聚簇索引则只需一次I&#x2F;O。（强烈的对比）</p>
<p>4.不过，如果涉及到大数据量的排序、全表扫描、count之类的操作的话，还是MyISAM占优势些，因为索引所占空间小，这些操作是需要在内存中完成的。</p>
<h6 id="主键建议使用自增id"><a href="#主键建议使用自增id" class="headerlink" title="主键建议使用自增id"></a>主键建议使用自增id</h6><p> 当使用主键为聚簇索引时，主键最好不要使用uuid，因为uuid的值太过离散，不适合排序且可能出线新增加记录的uuid，会插入在索引树中间的位置，导致索引树调整复杂度变大，消耗更多的时间和资源。</p>
<p>聚簇索引的数据的物理存放顺序与索引顺序是一致的，即：只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的。如果主键不是自增id，那么可以想 象，它会干些什么，不断地调整数据的物理地址、分页，当然也有其他一些措施来减少这些操作，但却无法彻底避免。但，如果是自增的，那就简单了，它只需要一 页一页地写，索引结构相对紧凑，磁盘碎片少，效率也高。</p>
<h5 id="主键索引-（primary-key）"><a href="#主键索引-（primary-key）" class="headerlink" title="主键索引 （primary key）"></a>主键索引 （primary key）</h5><p>也简称主键。它可以提高查询效率，并提供唯一性约束。一张表中只能有一个主键。被标志为自动增长的字段一定是主键，但主键不一定是自动增长。一般把主键定义在无意义的字段上（如：编号），主键的数据类型最好是数值。</p>
<p>一种方法在创建表的时候创建，再次是修改表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name <span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY (column_list)</span><br></pre></td></tr></table></figure>

<p>1</p>
<p>索引都能在创建表是指定</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student_score(</span><br><span class="line"> id <span class="type">int</span>(<span class="number">10</span>) auto_increment,</span><br><span class="line"> student_id <span class="type">int</span>(<span class="number">10</span>),</span><br><span class="line"> subject_id <span class="type">int</span>(<span class="number">10</span>),</span><br><span class="line"> score <span class="type">int</span>(<span class="number">10</span>),</span><br><span class="line"> <span class="keyword">primary</span> key (id),</span><br><span class="line"> index idx_student_id (student_id),</span><br><span class="line"> index idx_subject_id (subject_id)</span><br><span class="line">); </span><br></pre></td></tr></table></figure>



<blockquote>
<p>小tips：</p>
</blockquote>
<p>int(n)括号里面的数字表示显示宽度，不是代表能存放多少位数，始终占用4个字节的空间int(M) 跟 int 数据类型是相同的。int(M) 只有跟 zerofill 结合起来，才能使我们清楚的看到不同之处 1.创建表t</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> t(id <span class="type">int</span>(<span class="number">5</span>) zerofill);</span><br></pre></td></tr></table></figure>

<p>1</p>
<p>2.插入数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> t(id) <span class="keyword">values</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>1</p>
<p>3.显示select * from t</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00010</span><br></pre></td></tr></table></figure>

<p>1</p>
<h5 id="普通索引-（常规索引）-normal"><a href="#普通索引-（常规索引）-normal" class="headerlink" title="普通索引 （常规索引）(normal)"></a>普通索引 （常规索引）(normal)</h5><p>就是普普通通的索引，没有什么特殊要求，创建方式如下</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_indexName <span class="keyword">ON</span> mytable(username(length)); </span><br></pre></td></tr></table></figure>

<p>1</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_myDeptIndex <span class="keyword">on</span> detail(dept_id);</span><br></pre></td></tr></table></figure>

<p>1</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX [idx_indexName] <span class="keyword">ON</span> mytable; </span><br></pre></td></tr></table></figure>

<p>1</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name <span class="keyword">ADD</span> INDEX idx_index_name (column_list);</span><br></pre></td></tr></table></figure>

<p>1</p>
<h5 id="唯一索引（UNIQUE-）"><a href="#唯一索引（UNIQUE-）" class="headerlink" title="唯一索引（UNIQUE ）"></a>唯一索引（UNIQUE ）</h5><p>索引的值不能重复</p>
<p><strong>唯一索引（UNIQUE KEY）</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX ux_indexName <span class="keyword">ON</span> mytable(username(length)) </span><br></pre></td></tr></table></figure>

<p>1</p>
<p>修改表结构</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">table</span> mytable <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> [ux_indexName] (username(length))</span><br></pre></td></tr></table></figure>

<p>1</p>
<ul>
<li>主键是一种约束，唯一索引是一种索引，两者在本质上是不同的。</li>
<li>主键创建后一定包含一个唯一性索引，唯一性索引并不一定就是主键。</li>
<li>唯一性索引列允许空值，而主键列不允许为空值。</li>
<li>主键列在创建时，已经默认为非空值 + 唯一索引了。</li>
<li>主键可以被其他表引用为外键，而唯一索引不能。</li>
<li>一个表最多只能创建一个主键，但可以创建多个唯一索引。</li>
<li>主键更适合那些不容易更改的唯一标识，如自动递增列、身份证号等。</li>
</ul>
<h5 id="全文索引（FULLTEXT）"><a href="#全文索引（FULLTEXT）" class="headerlink" title="全文索引（FULLTEXT）"></a>全文索引（FULLTEXT）</h5><p>做全文检索使用的索引，我们有更好的替代品 ElacticSearch，所以实际使用不多，只当了解。</p>
<p>通过数值比较、范围过滤等就可以完成绝大多数我们需要的查询，但是，如果希望通过关键字的匹配来进行查询过滤，那么就需要基于相似度的查询，而不是原来的精确数值比较。全文索引就是为这种场景设计的。</p>
<p>你可能会说，用 like + % 就可以实现模糊匹配了，为什么还要全文索引？like + % 在文本比较少时是合适的，但是对于大量的文本数据检索，是不可想象的。全文索引在大量的数据面前，能比 like + % 快 N 倍，速度不是一个数量级，但是全文索引可能存在精度问题。</p>
<p>你可能没有注意过全文索引，不过至少应该对一种全文索引技术比较熟悉：各种的搜索引擎。虽然搜索引擎的索引对象是超大量的数据，并且通常其背后都不是关系型数据库，不过全文索引的基本原理是一样的。</p>
<blockquote>
<p>全文索引的版本支持</p>
</blockquote>
<ol>
<li>MySQL 5.6 以前的版本，只有 MyISAM 存储引擎支持全文索引；</li>
<li>MySQL 5.6 及以后的版本，MyISAM 和 InnoDB 存储引擎均支持全文索引;</li>
<li>只有字段的数据类型为 char、varchar、text 及其系列才可以建全文索引。</li>
</ol>
<blockquote>
<p>使用全文索引的注意</p>
</blockquote>
<ol>
<li>使用全文索引前，搞清楚版本支持情况；</li>
<li>全文索引比 like + % 快 N 倍，但是可能存在精度问题；</li>
<li>如果需要全文索引的是大量数据，建议先添加数据，再创建索引；</li>
<li>对于中文，可以使用 MySQL 5.7.6 之后的版本，或者第三方插件。</li>
</ol>
<p>1、创建表时创建全文索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> fulltext_test (</span><br><span class="line">    id <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    content text <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    tag <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id),</span><br><span class="line">    FULLTEXT KEY content_tag_fulltext(content,tag)  <span class="operator">/</span><span class="operator">/</span> 创建联合全文索引列</span><br><span class="line">) ENGINE<span class="operator">=</span>MyISAM <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;<span class="number">1234567</span></span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7</p>
<p>2、在已存在的表上创建全文索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> fulltext index content_tag_fulltext</span><br><span class="line">    <span class="keyword">on</span> fulltext_test(content,tag);</span><br></pre></td></tr></table></figure>

<p>1<br>2</p>
<p>3、通过 SQL 语句 ALTER TABLE 创建全文索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> fulltext_test</span><br><span class="line">    <span class="keyword">add</span> fulltext index content_tag_fulltext(content,tag);</span><br></pre></td></tr></table></figure>

<p>1<br>2</p>
<p>4、直接使用 DROP INDEX 删除全文索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> index content_tag_fulltext</span><br><span class="line">    <span class="keyword">on</span> fulltext_test;<span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>1<br>2</p>
<p>5、通过 SQL 语句 ALTER TABLE 删除全文索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> fulltext_test</span><br><span class="line">    <span class="keyword">drop</span> index content_tag_fulltext;</span><br></pre></td></tr></table></figure>

<p>1<br>2</p>
<p>6、全文检索的语法</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> <span class="keyword">match</span>(content) against(<span class="string">&#x27;aaa&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>1</p>
<h5 id="空间索引（SPATIAL）"><a href="#空间索引（SPATIAL）" class="headerlink" title="空间索引（SPATIAL）"></a>空间索引（SPATIAL）</h5><p>MySQL在5.7之后的版本支持了空间索引，而且支持OpenGIS几何数据模型。这是在地理位置领域使用的一种索引，其他场景用的很少，所以不需要深入学习。</p>
<h5 id="复合索引（联合索引）重要"><a href="#复合索引（联合索引）重要" class="headerlink" title="复合索引（联合索引）重要"></a>复合索引（联合索引）重要</h5><p>当有多个查询条件时，我们推荐使用复合索引。索引的<code>组合使用</code>（索引合并）效率是低于<code>复合索引</code>的。</p>
<p>比如：我们经常按照 A列 B列 C列进行查询时，通常的做法是建立一个由三个列共同组成的复合索引而不是对每一个列建立普通索引。</p>
<p><img src="/2022/09/01/mysql/image-20201130174603592.a2da4626.png" alt="image-20201130174603592"></p>
<p>关于复合索引的一些知识：</p>
<blockquote>
<p>为什么要使用联合索引</p>
</blockquote>
<p><strong>减少开销。</strong>建一个联合索引<code>(Gid,Cid,SId)</code>，实际相当于建了<code>(Gid)、(Gid,Cid)、(Gid,Cid,SId)</code>三个索引。每多一个索引，都会增加写操作的开销和磁盘空间的开销。对于大量数据的表，使用联合索引会大大的减少开销！</p>
<p><strong>覆盖索引。</strong>对联合索引<code>(Gid,Cid,SId)</code>，如果有如下的sql: select <code>Gid,Cid,SId</code> from student where <code>Gid</code>&#x3D;1 and <code>Cid</code>&#x3D;2。那么MySQL可以直接通过遍历索引取得数据，而无需回表，这减少了很多的随机io操作。减少io操作，特别的随机io其实是dba主要的优化策略。所以，在真正的实际应用中，覆盖索引是主要的提升性能的优化手段之一。</p>
<p><strong>效率高。</strong>索引列越多，通过索引筛选出的数据越少。有1000W条数据的表，有如下sql:select from table where <code>Gid</code>&#x3D;1 and <code>Cid</code>&#x3D;2 and <code>SId</code>&#x3D;3,假设假设每个条件可以筛选出10%的数据，如果只有单值索引，那么通过该索引能筛选出1000W10%&#x3D;100w条数据，然后再回表从100w条数据中找到符合<code>Gid</code>&#x3D;2 and <code>Cid</code>&#x3D; 3的数据，然后再排序，再分页；如果是联合索引，通过索引筛选出1000w10% 10% *10%&#x3D;1w，效率提升可想而知！</p>
<p><strong>缺点。</strong>联合索引越多，索引列越多，则创建的索引越多，索引都是存储在磁盘里的，通过索引算法(Btree代表索引算法使用二叉树的形式来做索引的)来查找数据，的确可以极大的提高查询效率，但是与此同时增删改的同时，需要更新索引，同样是需要花时间的，并且索引所占的磁盘空间也不小。</p>
<p><strong>建议。</strong>单表尽可能不要超过一个联合索引，单个联合索引不超过3个</p>
<blockquote>
<p>联合索引的创建注意事项</p>
</blockquote>
<p>1.<code>最左前缀匹配原则</code>，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a &#x3D; 1 and b &#x3D; 2 and c &gt; 3 and d &#x3D; 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</p>
<p>2.&#x3D;和in可以乱序，比如a &#x3D; 1 and b &#x3D; 2 and c &#x3D; 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。</p>
<p>把范围查询的字段放在后边</p>
<blockquote>
<p>创建联合索引，就是括号里多了几个列</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert <span class="keyword">table</span> test <span class="keyword">add</span> idx_clo1_col2 <span class="keyword">table</span> (a1,a2,a3) </span><br></pre></td></tr></table></figure>



<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_clo1_col2 <span class="keyword">on</span> <span class="keyword">table</span>(a1,a2,a3);</span><br></pre></td></tr></table></figure>



<h5 id="hash索引"><a href="#hash索引" class="headerlink" title="hash索引"></a>hash索引</h5><ul>
<li>hash相信大家应该都很熟悉，hash是一种key-value形式的数据结构。实现一般是数组+链表的结构，通过hash函数计算出key在数组中的位置，然后如果出现hash冲突就通过链表来解决。当然还有其他的解决hash冲突的方法。hash这种数据结构是很常用的，比如我们系统使用HashMap来构建热点数据缓存，存取效率很好。</li>
<li>hash结构存数据首先通过计算key的hash值来确定其在数组中的位置，如果有冲突就在该数组位置建一个链表。这样很明显有几个问题：</li>
<li>即使是具有相同特征的key计算出来的位置可能相隔很远，连续查询效率低下。即<code>不支持范围查询</code>。</li>
<li>hash索引存储的是计算得到的hash值和行指针，而不存储具体的行值，所以通过hash索引查询数据需要进行两次查询(首先查询行的位置，然后找到具体的数据)</li>
<li>hash索引查询数据的前提就是计算hash值，也就是要求key为一个能准确指向一条数据的key，所以对于like等一类的匹配查询是不支持的。</li>
<li><strong>所以我们可以知道的是hash索引适用于快速选取某一行的数据，超级大表中定位某一行特别快。</strong></li>
<li><strong>只要是只需要做等值比较查询，而不包含排序或范围查询的需求，都适合使用哈希索引。</strong></li>
</ul>
<p>创建的语法</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index index_test <span class="keyword">using</span> hash <span class="keyword">on</span> test1(id);</span><br></pre></td></tr></table></figure>



<p>你会发现创建了也没有用，因为InnoDB和myIsam都不支持hash索引。</p>
<p><img src="/2022/09/01/mysql/image-20201130170655340.e8a6028e-166201207344461.png" alt="image-20201130170655340"></p>
<blockquote>
<p>创建自定义hash索引</p>
</blockquote>
<p>若存储引擎不支持hash索引，又想拥有hash索引所带来的性能提升，则可以模拟InnoDB一样创建哈希索引。 　　思路也比较简单，就是在B+tree基础上创建一个伪哈希索引。这和真正的hash索引不是一回事，因为还是采用B-Tree进行查找，但是它使用的是hash值而不是键本身进行查找。只需要在查询的where子句中手动指定使用hash函数即可。下面举个简单的例子：</p>
<p>比如：当我们需要存储大量的URL，并需要根据URL进行搜索查找。若用B-Tree来存储URL，存储的内容就会很大。此时的查询语句就是：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> url <span class="keyword">where</span> url <span class="operator">=</span> &quot;www.baidu.com&quot;;</span><br></pre></td></tr></table></figure>



<p>若删除原来的url列上的索引，而新增一个被索引的url_crc列，使用crc32做hash函数，则可以使用如下方式查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> url <span class="keyword">where</span> url <span class="operator">=</span> &quot;www.baidu.com&quot; <span class="keyword">and</span> url_crc<span class="operator">=</span>CRC32(&quot;www.baidu.com&quot;);</span><br></pre></td></tr></table></figure>



<p>这样做的话，性能就会有很大提升，因为mysql优化器会使用这个选择性高而体积很小的基于url_crc列的索引来完成查找。即使有多个记录相同的索引值，查找仍然很快，只需要根据hash值做快速的整数比较就能找到索引条目，然后一一返回对应的行。</p>
<p><strong>缺点</strong> 1、需要维护hash值，可以手动维护，也可以使用触发器实现。 2、若数据表非常大的话，CRC32（）会出现大量hash冲突，则可以自己实现一个64位的hash函数，这个自定义的hash函数要返回整数而不是字符串，因为范围整数，对此效率更高。一个简单的办法就是使用MD5（）函数返回值的一部分来作为自定义的hash函数。但是这可能比自己写一个hash算法性能要差一些。</p>
<p>案例博客：<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000003741888">https://segmentfault.com/a/1190000003741888</a></p>
<h4 id="navicat中创建索引"><a href="#navicat中创建索引" class="headerlink" title="navicat中创建索引"></a>navicat中创建索引</h4><p>设计表中的索引模块</p>
<p><img src="/2022/09/01/mysql/image-20201130174637501.3643489b-166201207344462.png" alt="image-20201130174637501"></p>
<h4 id="使用索引的问题"><a href="#使用索引的问题" class="headerlink" title="使用索引的问题"></a>使用索引的问题</h4><p>设计好MySql的索引可以让你的数据库飞起来，大大的提高数据库效率。</p>
<p>但是你设计了索引就一定会用到码？索引就不会给你带来一些问题吗？</p>
<p>设计MySql索引的时候有一下几点注意：</p>
<h5 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h5><p>对于<code>查询占主要</code>的应用来说，索引显得尤为重要。很多时候性能问题很简单的就是因为我们忘了添加索引而造成的，或者说没有添加更为有效的索引导致。如果不加索引的话，那么查找任何哪怕只是一条特定的数据都会进行一次全表扫描，如果一张表的数据量很大而符合条件的结果又很少，那么不加索引会引起致命的性能下降。但是也不是什么情况都非得建索引不可，比如性别可能就只有两个值，建索引不仅没什么优势，还会影响到更新速度，这被称为过度索引。</p>
<blockquote>
<p>哪些情况下适合建索引</p>
</blockquote>
<ol>
<li><p>频繁作为where条件语句查询的字段</p>
</li>
<li><p>关联字段需要建立索引，例如外键字段，student表中的classid, classes表中的schoolid 等</p>
</li>
<li><p>排序字段可以建立索引</p>
</li>
<li><p>分组字段可以建立索引，因为分组的前提是排序</p>
</li>
<li><p>统计字段可以建立索引，例如count(),max()</p>
</li>
</ol>
<blockquote>
<p>哪些情况下不适合建索引</p>
</blockquote>
<pre><code> 1.频繁更新的字段不适合建立索引
</code></pre>
<p>​	2.where条件中用不到的字段不适合建立索引</p>
<p>​	3.表数据可以确定比较少的不需要建索引</p>
<p>​	4.数据重复且发布比较均匀的的字段不适合建索引（唯一性太差的字段不适合建立索引），例如性别，真假值</p>
<p>​	假如索引列TYPE有5个键值，如果有1万条数据，那么 WHERE TYPE &#x3D; 1将访问表中的2000个数据块。再加上访问索引块，一共要访问大于200个的数据块。如果全表扫描，假设10条数据一个数据块，那么只需访问1000个数据块，既然全表扫描访问的数据块少一些，肯定就不会利用索引了。</p>
<p>​	5.参与列计算的列不适合建索引，索引会失效</p>
<h5 id="习惯使用复合索引"><a href="#习惯使用复合索引" class="headerlink" title="习惯使用复合索引"></a>习惯使用复合索引</h5><p>比如有一条语句是这样的：select * from users where area&#x3D;’beijing’ and age&#x3D;22;</p>
<p>如果我们是在area和age上分别创建单个索引的话，由于mysql查询每次只能使用一个索引，所以虽然这样已经相对不做索引时全表扫描提高了很多效</p>
<p>率，但是如果在area、age两列上创建复合索引的话将带来更高的效率。如果我们创建了(area, age,</p>
<p>salary)的复合索引，那么其实相当于创建了(area,age,salary)、(area,age)、(area)三个索引，这被称为最佳左前缀</p>
<p>特性。因此我们在创建复合索引时应该将最常用作限制条件的列放在最左边，依次递减。</p>
<h5 id="索引不会包含有NULL值的列"><a href="#索引不会包含有NULL值的列" class="headerlink" title="索引不会包含有NULL值的列"></a>索引不会包含有NULL值的列</h5><p>a.单列索引无法储null值，复合索引无法储全为null的值。</p>
<p>b.查询时，采用is null条件时，不能利用到索引，只能全表扫描。</p>
<p>为什么索引列无法存储Null值？</p>
<p>a.索引是有序的。NULL值进入索引时，无法确定其应该放在哪里。（将索引列值进行建树，其中必然涉及到诸多的比较操作，null 值是不确定值无法</p>
<p>比较，无法确定null出现在索引树的叶子节点位置。）</p>
<p>b.如果需要把空值存入索引，方法有二：其一，把NULL值转为一个特定的值，在WHERE中检索时，用该特定值查找。其二，建立一个复合索引。例如</p>
<p>create index ind_a on table(col1,1); 通过在复合索引中指定一个非空常量值，而使构成索引的列的组合中，不可能出现全空值。</p>
<h5 id="使用短索引"><a href="#使用短索引" class="headerlink" title="使用短索引"></a>使用短索引</h5><p>对串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个CHAR(255)的 列，如果在前10 个或20 个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I&#x2F;O操作。</p>
<h5 id="排序的索引问题"><a href="#排序的索引问题" class="headerlink" title="排序的索引问题"></a>排序的索引问题</h5><p>mysql查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建<code>复合索引</code>。</p>
<h5 id="MySQL索引失效的几种情况"><a href="#MySQL索引失效的几种情况" class="headerlink" title="MySQL索引失效的几种情况"></a>MySQL索引失效的几种情况</h5><ul>
<li>如果条件中有or，即使其中有条件带索引也不会使用(这也是为什么尽量少用or的原因)要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引</li>
<li>复合索引不满足最左原则就不能使用索引</li>
<li>like查询以%开头</li>
<li>如果mysql估计使用全表扫描要比使用索引快,则不使用索引</li>
</ul>
<h5 id="MySQL主要提供2种方式的索引：B-Tree索引，Hash索引"><a href="#MySQL主要提供2种方式的索引：B-Tree索引，Hash索引" class="headerlink" title="MySQL主要提供2种方式的索引：B-Tree索引，Hash索引"></a>MySQL主要提供2种方式的索引：B-Tree索引，Hash索引</h5><ul>
<li>B树索引具有<strong>范围查找和前缀查找的能力</strong>，对于有N节点的B树，检索一条记录的复杂度为O(LogN)。相当于二分查找。</li>
<li>哈希索引只能做等于查找，但是无论多大的Hash表，查找复杂度都是O(1)。</li>
<li>显然，如果值的差异性大，并且以等值查找（&#x3D;、 &lt;、&gt;、in）为主，Hash索引是更高效的选择，它有O(1)的查找复杂度。</li>
<li>如果值的差异性相对较差，并且以范围查找为主，B树是更好的选择，它支持范围查找。</li>
</ul>
<h5 id="面试回答问题"><a href="#面试回答问题" class="headerlink" title="面试回答问题"></a>面试回答问题</h5><p>为什么要建立索引？</p>
<p>因为如果数据比较多的话， 一个个去遍历比较会比较慢。如果使用索引的话，索引是有组织过的数据。是有序的，可以更快的查到数据。有序的结构可以更快查到数据，例如，一个无需的数组，咱们需要遍历全部元素才可以查询到数据。但是如果排过数据，就可以二分查询。</p>
<p>innoDB 当然不是使用数组的形式来构建数据，innoDB采用了 B + 树来进行构建数据，该数据结构，在每个节点上可以保存更多的关键字，来减少层级。这样可以减少IO次数。在叶子节点通过指针链接在一起。可以用来做范围查询。 同时，内存页加载到相邻数据更多，又进一步减少了访问IO次数。 磁盘IO是关系型数据库主要要解决的问题，解决了磁盘IO问题才可以更快响应应用程序。Mysql的索引很大一部分都是围绕这个点进行的。 </p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36520235/article/details/94317993">(37条消息) 为什么MySQL使用B+而不是使用B树、二叉树、AVL树呢？（来龙去脉的去理解）_王伟的博客-CSDN博客_mysql为什么用b+,不用b</a></p>
<p>为什么使用B+ 树而不使用B树？</p>
<p> 原因是，B+ 树的数据都是存在</p>
<h4 id="explain关键字"><a href="#explain关键字" class="headerlink" title="explain关键字"></a>explain关键字</h4><blockquote>
<p>explain关键字可以模拟MySQL优化器执行SQL语句，可以很好的分析SQL语句或表结构的性能瓶颈。</p>
</blockquote>
<h5 id="explain的用途"><a href="#explain的用途" class="headerlink" title="explain的用途"></a>explain的用途</h5><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 表的读取顺序如何</span><br><span class="line">2. 数据读取操作有哪些操作类型</span><br><span class="line">3. 哪些索引可以使用</span><br><span class="line">4. 哪些索引被实际使用</span><br><span class="line">5. 表之间是如何引用</span><br><span class="line">6. 每张表有多少行被优化器查询</span><br><span class="line">......</span><br></pre></td></tr></table></figure>



<h5 id="explain的执行效果"><a href="#explain的执行效果" class="headerlink" title="explain的执行效果"></a>explain的执行效果</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> subject <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> </span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">           id: <span class="number">1</span></span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        <span class="keyword">table</span>: subject</span><br><span class="line">   partitions: <span class="keyword">NULL</span></span><br><span class="line">         type: const</span><br><span class="line">possible_keys: <span class="keyword">PRIMARY</span></span><br><span class="line">          key: <span class="keyword">PRIMARY</span></span><br><span class="line">      key_len: <span class="number">4</span></span><br><span class="line">          <span class="keyword">ref</span>: const</span><br><span class="line">         <span class="keyword">rows</span>: <span class="number">1</span></span><br><span class="line">     filtered: <span class="number">100.00</span></span><br><span class="line">        Extra: <span class="keyword">NULL</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br></pre></td></tr></table></figure>



<h5 id="explain包含的字段"><a href="#explain包含的字段" class="headerlink" title="explain包含的字段"></a>explain包含的字段</h5><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1. id //select查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序</span><br><span class="line">2. select_type //查询类型</span><br><span class="line">3. table //正在访问哪个表</span><br><span class="line">4. partitions //匹配的分区</span><br><span class="line">5. type //访问的类型</span><br><span class="line">6. possible_keys //显示可能应用在这张表中的索引，一个或多个，但不一定实际使用到</span><br><span class="line">7. key //实际使用到的索引，如果为NULL，则没有使用索引</span><br><span class="line">8. key_len //表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度</span><br><span class="line">9. ref //显示索引的哪一列被使用了，如果可能的话，是一个常数，哪些列或常量被用于查找索引列上的值</span><br><span class="line">10. rows //根据表统计信息及索引选用情况，大致估算出找到所需的记录所需读取的行数</span><br><span class="line">11. filtered //查询的表行占表的百分比</span><br><span class="line">12. Extra //包含不适合在其它列中显示但十分重要的额外信息</span><br></pre></td></tr></table></figure>



<h6 id="id字段"><a href="#id字段" class="headerlink" title="id字段"></a>id字段</h6><p><strong>1. id相同</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">执行顺序从上至下</span><br><span class="line">例子：</span><br><span class="line">explain select subject.* from subject,student_score,teacher where subject.id = student_id and subject.teacher_id = teacher.id;</span><br><span class="line">读取顺序：subject &gt; teacher &gt; student_score</span><br></pre></td></tr></table></figure>



<p><img src="/2022/09/01/mysql/image-20211220185904178.23754ea6-166201207344463.png" alt="image-20211220185904178"></p>
<p><strong>2. id不同</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如果是子查询，id的序号会递增，id的值越大优先级越高，越先被执行</span><br><span class="line">例子：</span><br><span class="line">explain select score.* from student_score as score where subject_id =  (select id from subject where teacher_id = (select id from teacher where id = 2));</span><br><span class="line">读取顺序：teacher &gt; subject &gt; student_score</span><br></pre></td></tr></table></figure>



<p><img src="/2022/09/01/mysql/image-20211220185917085.26c148d2.png" alt="image-20211220185917085"></p>
<p><strong>3. id相同又不同</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">id如果相同，可以认为是一组，从上往下顺序执行</span><br><span class="line">在所有组中，id值越大，优先级越高，越先执行</span><br><span class="line">例子：</span><br><span class="line">explain select subject.* from subject left join teacher on subject.teacher_id = teacher.id</span><br><span class="line">nion </span><br><span class="line"> -&gt; select subject.* from subject right join teacher on subject.teacher_id = teacher.id;</span><br><span class="line"> 读取顺序：2.teacher &gt; 2.subject &gt; 1.subject &gt; 1.teacher</span><br></pre></td></tr></table></figure>



<p><img src="/2022/09/01/mysql/image-20211220185929385.01a7907f-166201207344464.png" alt="image-20211220185929385"></p>
<h6 id="select-type字段"><a href="#select-type字段" class="headerlink" title="select_type字段"></a>select_type字段</h6><p><strong>1. SIMPLE</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">简单查询，不包含子查询或Union查询</span><br><span class="line">例子：</span><br><span class="line">explain select subject.* from subject,student_score,teacher where subject.id = student_id and subject.teacher_id = teacher.id;</span><br></pre></td></tr></table></figure>



<p><img src="/2022/09/01/mysql/image-20211220185949668.a206a040-166201207344465.png" alt="image-20211220185949668"></p>
<p><strong>2. PRIMARY</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">查询中若包含任何复杂的子部分，最外层查询则被标记为主查询</span><br><span class="line">例子：</span><br><span class="line">explain select score.* from student_score as score where subject_id = (select id from subject where teacher_id = (select id from teacher where id = 2));</span><br></pre></td></tr></table></figure>



<p><img src="/2022/09/01/mysql/image-20211220190000990.b9749798-166201207344466.png" alt="image-20211220190000990"></p>
<p><strong>3. SUBQUERY</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在select或where中包含子查询</span><br><span class="line">例子：</span><br><span class="line">explain select score.* from student_score as score where subject_id = (select id from subject where teacher_id = (select id from teacher where id = 2));</span><br></pre></td></tr></table></figure>



<p><img src="/2022/09/01/mysql/image-20211220190011526.c55c03f5-166201207344467.png" alt="image-20211220190011526"></p>
<p><strong>4. DERIVED</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在FROM列表中包含的子查询被标记为DERIVED（衍生），MySQL</span><br><span class="line">会递归执行这些子查询，把结果放在临时表中</span><br><span class="line">备注：</span><br><span class="line">MySQL5.7+ 进行优化了，增加了derived_merge（派生合并），默认开启，可加快查询效率</span><br></pre></td></tr></table></figure>



<p><strong>5. UNION</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">若第二个select出现在uion之后，则被标记为UNION</span><br><span class="line">例子：</span><br><span class="line">explain select subject.* from subject left join teacher on subject.teacher_id = teacher.id</span><br><span class="line"> -&gt; union </span><br><span class="line"> -&gt; select subject.* from subject right join teacher on subject.teacher_id = teacher.id;</span><br></pre></td></tr></table></figure>



<p><img src="/2022/09/01/mysql/image-20211220190022655.fbcb13a5.png" alt="image-20211220190022655"></p>
<p><strong>6. UNION RESULT</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">从UNION表获取结果的select</span><br><span class="line">例子：</span><br><span class="line">explain select subject.* from subject left join teacher on subject.teacher_id = teacher.id</span><br><span class="line"> -&gt; union </span><br><span class="line"> -&gt; select subject.* from subject right join teacher on subject.teacher_id = teacher.id;</span><br></pre></td></tr></table></figure>



<p><img src="/2022/09/01/mysql/image-20211220190032207.191959be-166201207344468.png" alt="image-20211220190032207"></p>
<h6 id="type字段"><a href="#type字段" class="headerlink" title="type字段"></a>type字段</h6><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NULL&gt;system&gt;const&gt;eq_ref&gt;ref&gt;fulltext&gt;ref_or_null&gt;index_merge&gt;unique_subquery&gt;index_subquery&gt;range&gt;index&gt;ALL //最好到最差</span><br><span class="line">备注：掌握以下10种常见的即可</span><br><span class="line">NULL&gt;system&gt;const&gt;eq_ref&gt;ref&gt;ref_or_null&gt;index_merge&gt;range&gt;index&gt;ALL</span><br></pre></td></tr></table></figure>



<p><strong>1. NULL</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MySQL能够在优化阶段分解查询语句，在执行阶段用不着再访问表或索引，比如通过id没有找到</span><br><span class="line">例子：</span><br><span class="line">explain select min(id) from subject;</span><br></pre></td></tr></table></figure>



<p><img src="/2022/09/01/mysql/image-20211220190040931.415a680d-166201207344469.png" alt="image-20211220190040931"></p>
<p><strong>2. system</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表只有一行记录（等于系统表），这是const类型的特列，平时不大会出现，可以忽略</span><br></pre></td></tr></table></figure>

<p><strong>3. const</strong></p>
<p>只有唯一索引和id才能出现</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">表示通过索引一次就找到了，const用于比较primary key或uique索引，因为只匹配一行数据，所以很快，如主键置于where列表中，MySQL就能将该查询转换为一个常量</span><br><span class="line">例子：</span><br><span class="line">explain select * from teacher where teacher_no = &#x27;T2010001&#x27;;</span><br></pre></td></tr></table></figure>



<p><img src="/2022/09/01/mysql/image-20211220190050963.5889db4d-166201207344470.png" alt="image-20211220190050963"></p>
<p><strong>4. eq_ref</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配，常见于主键或唯一索引扫描</span><br><span class="line">例子：</span><br><span class="line">explain select subject.* from subject left join teacher on subject.teacher_id = teacher.id;</span><br></pre></td></tr></table></figure>



<p><img src="/2022/09/01/mysql/image-20211220190059802.86cdfcad-166201207344471.png" alt="image-20211220190059802"></p>
<p><strong>5. ref</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">非唯一性索引扫描，返回匹配某个单独值的所有行</span><br><span class="line">本质上也是一种索引访问，返回所有匹配某个单独值的行</span><br><span class="line">然而可能会找到多个符合条件的行，应该属于查找和扫描的混合体</span><br><span class="line">例子：</span><br><span class="line">explain select subject.* from subject,student_score,teacher where subject.id = student_id and subject.teacher_id = teacher.id;</span><br></pre></td></tr></table></figure>



<p><img src="/2022/09/01/mysql/image-20211220190109040.7592f0f1.png" alt="image-20211220190109040"></p>
<p><strong>6. ref_or_null</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">类似ref，但是可以搜索值为NULL的行</span><br><span class="line">例子：</span><br><span class="line">explain select * from teacher where name = &#x27;wangsi&#x27; or name is null;</span><br></pre></td></tr></table></figure>



<p><img src="/2022/09/01/mysql/image-20211220190118650.a4c59aa4-166201207344472.png" alt="image-20211220190118650"></p>
<p><strong>7. index_merge</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">表示使用了索引合并的优化方法</span><br><span class="line">例子：</span><br><span class="line">explain select * from teacher where id = 1 or teacher_no = &#x27;T2010001&#x27; .</span><br></pre></td></tr></table></figure>



<p><img src="/2022/09/01/mysql/image-20211220190129635.fb995207.png" alt="image-20211220190129635"></p>
<p><strong>8. range</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">只检索给定范围的行，使用一个索引来选择行，key列显示使用了哪个索引</span><br><span class="line">一般就是在你的where语句中出现between、&lt;&gt;、in等的查询。</span><br><span class="line">例子：</span><br><span class="line">explain select * from subject where id between 1 and 3;</span><br></pre></td></tr></table></figure>



<p><img src="/2022/09/01/mysql/image-20211220190140237.0513300b-166201207344473.png" alt="image-20211220190140237"></p>
<p><strong>9. index</strong>（全索引扫描）</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Full index Scan，Index与All区别：index只遍历索引树，通常比All快</span><br><span class="line">因为索引文件通常比数据文件小，也就是虽然all和index都是读全表，但index是从索引中读取的，而all是从硬盘读的。</span><br><span class="line">例子：</span><br><span class="line">explain select id from subject;</span><br></pre></td></tr></table></figure>



<p><img src="/2022/09/01/mysql/image-20211220190149239.5f833d80-166201207344474.png" alt="image-20211220190149239"></p>
<p><strong>10. ALL</strong>（全表扫）</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Full Table Scan，将遍历全表以找到匹配行</span><br><span class="line">例子：</span><br><span class="line">explain select * from subject;</span><br></pre></td></tr></table></figure>



<p><img src="/2022/09/01/mysql/image-20211220190158161.936afdb3-166201207344475.png" alt="image-20211220190158161"></p>
<h6 id="table字段"><a href="#table字段" class="headerlink" title="table字段"></a>table字段</h6><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据来自哪张表</span><br></pre></td></tr></table></figure>



<h6 id="possible-keys字段"><a href="#possible-keys字段" class="headerlink" title="possible_keys字段"></a>possible_keys字段</h6><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">显示可能应用在这张表中的索引，一个或多个</span><br><span class="line">查询涉及到的字段若存在索引，则该索引将被列出，但不一定被实际使用</span><br></pre></td></tr></table></figure>



<h6 id="key字段"><a href="#key字段" class="headerlink" title="key字段"></a>key字段</h6><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">实际使用到的索引，如果为NULL，则没有使用索引</span><br><span class="line">查询中若使用了覆盖索引（查询的列刚好是索引），则该索引仅出现在key列表</span><br></pre></td></tr></table></figure>



<h6 id="key-len字段"><a href="#key-len字段" class="headerlink" title="key_len字段"></a>key_len字段</h6><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度</span><br><span class="line">在不损失精确度的情况下，长度越短越好</span><br><span class="line">key_len显示的值为索引字段最大的可能长度，并非实际使用长度</span><br><span class="line">即key_len是根据定义计算而得，不是通过表内检索出的</span><br></pre></td></tr></table></figure>



<h6 id="ref字段"><a href="#ref字段" class="headerlink" title="ref字段"></a>ref字段</h6><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">显示索引的哪一列被使用了，如果可能的话，是一个常数，哪些列或常量被用于查找索引列上的值</span><br></pre></td></tr></table></figure>



<h6 id="rows字段"><a href="#rows字段" class="headerlink" title="rows字段"></a>rows字段</h6><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">根据表统计信息及索引选用情况，大致估算出找到所需的记录所需读取的行数</span><br></pre></td></tr></table></figure>

<h6 id="partitions字段"><a href="#partitions字段" class="headerlink" title="partitions字段"></a>partitions字段</h6><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">匹配的分区</span><br></pre></td></tr></table></figure>

<h6 id="filtered字段"><a href="#filtered字段" class="headerlink" title="filtered字段"></a>filtered字段</h6><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">查询的表行占表的百分比</span><br></pre></td></tr></table></figure>

<h6 id="Extra字段"><a href="#Extra字段" class="headerlink" title="Extra字段"></a>Extra字段</h6><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">包含不适合在其它列中显示但十分重要的额外信息</span><br></pre></td></tr></table></figure>



<ol>
<li><strong>Using filesort</strong></li>
</ol>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">说明MySQL会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取</span><br><span class="line">MySQL中无法利用索引完成的排序操作称为“文件排序”</span><br><span class="line">例子：</span><br><span class="line">explain select * from subject order by name;</span><br></pre></td></tr></table></figure>



<p><img src="/2022/09/01/mysql/image-20211220190212555.1b4db533-166201207344476.png" alt="image-20211220190212555"></p>
<p><strong>2. Using temporary</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">使用了临时表保存中间结果，MySQL在对结果排序时使用临时表，常见于排序order by 和分组查询group by</span><br><span class="line">例子：</span><br><span class="line">explain select subject.* from subject left join teacher on subject.teacher_id = teacher.id</span><br><span class="line"> -&gt; union </span><br><span class="line"> -&gt; select subject.* from subject right join teacher on subject.teacher_id = teacher.id;</span><br></pre></td></tr></table></figure>



<p><img src="/2022/09/01/mysql/image-20211220190220539.3dc53162.png" alt="image-20211220190220539"></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">表示相应的select操作中使用了覆盖索引（Covering Index）,避免访问了表的数据行，效率不错！</span><br><span class="line">如果同时出现using where，表明索引被用来执行索引键值的查找</span><br><span class="line">如果没有同时出现using where，表明索引用来读取数据而非执行查找动作</span><br><span class="line">例子：</span><br><span class="line">explain select subject.* from subject,student_score,teacher where subject.id = student_id and subject.teacher_id = teacher.id;</span><br><span class="line">备注：</span><br><span class="line">覆盖索引：select的数据列只用从索引中就能够取得，不必读取数据行，MySQL可以利用索引返回select列表中的字段，而不必根据索引再次读取数据文件，即查询列要被所建的索引覆盖</span><br></pre></td></tr></table></figure>



<p><img src="/2022/09/01/mysql/image-20211220190229214.0e36b860.png" alt="image-20211220190229214"></p>
<p><strong>3. Using where</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用了where条件</span><br><span class="line">例子：</span><br><span class="line">explain select subject.* from subject,student_score,teacher where subject.id = student_id and subject.teacher_id = teacher.id;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/09/01/mysql/image-20211220190242306.f11b316e.png" alt="image-20211220190242306"></p>
<p><strong>4. Using join buffer</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用了连接缓存</span><br><span class="line">例子：</span><br><span class="line">explain select student.*,teacher.*,subject.* from student,teacher,subject;</span><br></pre></td></tr></table></figure>



<p><img src="/2022/09/01/mysql/image-20211220190252786.92be6455.png" alt="image-20211220190252786"></p>
<p><strong>5. impossible where</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">where子句的值总是false，不能用来获取任何元组</span><br><span class="line">例子：</span><br><span class="line">explain select * from teacher where name = &#x27;wangsi&#x27; and name = &#x27;lisi&#x27;;</span><br></pre></td></tr></table></figure>



<p><img src="/2022/09/01/mysql/image-20211220190304170.89f489f0-166201207344477.png" alt="image-20211220190304170"></p>
<p><strong>6. distinct</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一旦mysql找到了与行相联合匹配的行，就不再搜索了</span><br><span class="line">例子：</span><br><span class="line">explain select distinct teacher.name from teacher left join subject on teacher.id = subject.teacher_id;</span><br></pre></td></tr></table></figure>



<p><img src="/2022/09/01/mysql/image-20211220190315525.43c223db-166201207344478.png" alt="image-20211220190315525"></p>
<p><strong>7. Select tables optimized away</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT操作已经优化到不能再优化了（MySQL根本没有遍历表或索引就返回数据了）</span><br><span class="line">例子：</span><br><span class="line">explain select min(id) from subject;</span><br></pre></td></tr></table></figure>



<p><img src="/2022/09/01/mysql/image-20211220190327314.2c8c39ce-166201207339755.png" alt="image-20211220190327314"></p>
<h2 id="Mysql事务"><a href="#Mysql事务" class="headerlink" title="Mysql事务"></a>Mysql事务</h2><h4 id="事务简介"><a href="#事务简介" class="headerlink" title="事务简介"></a>事务简介</h4><p>(1)在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。 (2)事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。 (3)事务用来管理 insert,update,delete 语句。</p>
<h4 id="事务四大特征"><a href="#事务四大特征" class="headerlink" title="事务四大特征"></a>事务四大特征</h4><p>一般来说，事务是必须满足4个条件（ACID）：</p>
<h5 id="原子性（Atomicity）"><a href="#原子性（Atomicity）" class="headerlink" title="原子性（Atomicity）"></a>原子性（Atomicity）</h5><p>一个事务（transaction）中的所有操作，<strong>要么全部完成，要么全部不完成</strong>，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</p>
<h5 id="一致性（Consistency）"><a href="#一致性（Consistency）" class="headerlink" title="一致性（Consistency）"></a>一致性（Consistency）</h5><p>在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。(<strong>比如：A向B转账，不可能A扣了钱，B却没有收到</strong>)</p>
<h5 id="隔离性（Isolation）"><a href="#隔离性（Isolation）" class="headerlink" title="隔离性（Isolation）"></a>隔离性（Isolation）</h5><p>数据库<strong>允许多个并发事务同时对其数据进行读写和修改的能力</strong>，隔离性可以防止多个事务并发执行时由于<strong>交叉执行而导致数据的不一致</strong>。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。（比u人：A正在从一张银行卡里面取钱，在A取钱的过程中，B不能向这张银行卡打钱）</p>
<h5 id="持久性（Durability）"><a href="#持久性（Durability）" class="headerlink" title="持久性（Durability）"></a>持久性（Durability）</h5><p>事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p>
<h4 id="事务提交、回滚"><a href="#事务提交、回滚" class="headerlink" title="事务提交、回滚"></a>事务提交、回滚</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- UNSIGNED代表无符号数，不能是负数 </span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span>(</span><br><span class="line">	id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">	name <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">	balance <span class="type">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>) UNSIGNED</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="string">&#x27;楠哥&#x27;</span>,<span class="number">200</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> <span class="keyword">VALUES</span> (<span class="number">2</span>,<span class="string">&#x27;楠哥老婆&#x27;</span>,<span class="number">50000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 转账业务，必须都成功，或者都失败，所以不能一句一句执行，万一执行了一半，断电了咋办</span></span><br><span class="line"><span class="comment">-- 所以要编程一个整体</span></span><br><span class="line"><span class="comment">-- 都成功</span></span><br><span class="line"><span class="comment">-- begin;</span></span><br><span class="line"><span class="keyword">start</span> transaction;    </span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">set</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">200</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">set</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">200</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 都失败</span></span><br><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">set</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">200</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">set</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">200</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">rollback</span>;</span><br></pre></td></tr></table></figure>



<h4 id="事务特性–隔离性"><a href="#事务特性–隔离性" class="headerlink" title="事务特性–隔离性"></a>事务特性–隔离性</h4><p>隔离强调的是两个或两个以上同时发生（并发）的业务同时操作一个数据库，为了让两个事务一方面能都看到、得到正确的结果，一方面还要保证一定的效率而产生的不同的隔离级别。</p>
<h5 id="隔离性有隔离级别"><a href="#隔离性有隔离级别" class="headerlink" title="隔离性有隔离级别"></a>隔离性有隔离级别</h5><p>（1）读未提交：read uncommitted （2）读已提交：read committed （3）可重复读：repeatable read （4）串行化：serializable</p>
<table>
<thead>
<tr>
<th></th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>Read uncommitted</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>Read committed</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>Repeatable read</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>Serializable</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<p>查看个设置事务的隔离级别：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@global</span>.tx_isolation, @<span class="variable">@tx</span>_isolation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> session transaction isolation level repeatable read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span>  transaction isolation level read uncommitted;</span><br><span class="line"><span class="keyword">SET</span>  transaction isolation level read committed;</span><br><span class="line"><span class="keyword">set</span>  transaction isolation level repeatable read;</span><br><span class="line"><span class="keyword">SET</span>  transaction isolation level serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> transaction isolation level read uncommitted;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> transaction isolation level read committed;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">GLOBAL</span> transaction isolation level repeatable read;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> transaction isolation level serializable;</span><br><span class="line"></span><br><span class="line">其中，SESSION 和 <span class="keyword">GLOBAL</span> 关键字用来指定修改的事务隔离级别的范围：</span><br><span class="line">SESSION：表示修改的事务隔离级别将应用于当前 session（当前 cmd 窗口）内的所有事务；</span><br><span class="line"><span class="keyword">GLOBAL</span>：表示修改的事务隔离级别将应用于所有 session（全局）中的所有事务，且当前已经存在的 session 不受影响；</span><br><span class="line">如果省略 SESSION 和 <span class="keyword">GLOBAL</span>，表示修改的事务隔离级别将应用于当前 session 内的下一个还未开始的事务。</span><br></pre></td></tr></table></figure>



<h6 id="读未提交"><a href="#读未提交" class="headerlink" title="读未提交"></a>读未提交</h6><ul>
<li>事物A和事物B，事物A未提交的数据，事物B可以读取到</li>
<li>这里读取到的数据叫做“脏数据”，叫脏读</li>
<li>这种隔离级别最低，这种级别一般是在理论上存在，数据库隔离级别一般都高于该级别</li>
</ul>
<p>简而言之第一个事务没提交，别的事物就能读，这种数据不一定是正确的因为人家可能回滚呀！</p>
<p><strong>案例：</strong></p>
<p>楠哥发工资了，老婆让楠哥把工资打到他老婆的账号上，但是该事务并未提交，就让老婆去查看，老婆一看真的打了钱了，高高兴兴关了网页，此时楠哥急中生智进行回滚，钱瞬间回来，一次蒙混了一个月工资。所以楠哥老婆看到的数据我们称之为“脏数据”。</p>
<p>必须开两个事务</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use test;</span><br><span class="line"><span class="keyword">SET</span>  transaction isolation level read uncommitted;</span><br></pre></td></tr></table></figure>

<p>1-楠哥，转账</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">set</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">10000</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">set</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">10000</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>2-楠哥老婆，查账，不错，钱已到账</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>

<p>3-楠哥,回马枪，回滚</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rollback</span>;</span><br></pre></td></tr></table></figure>

<p>4-楠老婆某天查账，哎，怎么少了一万</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>

<p>出现上述情况，即我们所说的脏读 ，两个并发的事务，“事务A：领导给singo发工资”、“事务B：singo查询工资账户”，事务B读取了事务A尚未提交的数据。</p>
<h6 id="读已提交"><a href="#读已提交" class="headerlink" title="读已提交"></a>读已提交</h6><p>能读到别的事物已经提交的数据。</p>
<p>A事务在本次事务中，对自己操作过的数据，进行了多次读取发现数据不一致，不可重复读。</p>
<p>简单点说就是不能让我好好的重复读，一个事务里读出来的数据都不一样，让不让人干活了。</p>
<p>针对的语句update和delete，会导致不可重复读</p>
<p>楠哥拿着工资卡去消费，系统读取到卡里确实有10200元，而此时她的老婆也正好在网上转账，把楠哥工资卡的2000元转到另一账户，并在 楠哥之前提交了事务，当楠哥扣款时，系统检查到楠哥的工资卡和上次读取的不一样了，楠哥十分纳闷，明明卡里有钱，为何……</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET  transaction isolation level read committed;</span><br></pre></td></tr></table></figure>

<p>1-楠哥去消费了，显示有余额，贼高兴</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">select * from user where id = 1;</span><br></pre></td></tr></table></figure>

<p>2-老婆转账</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">set</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">500</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">set</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">500</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3-楠哥查账，同一个事务里，发现钱少了。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>当隔离级别设置为Read committed 时，避免了脏读，但是可能会造成不可重复读。</p>
<p>大多数数据库的默认级别就是Read committed，比如Sql Server , Oracle。如何解决不可重复读这一问题，请看下一个隔离级别。</p>
<h6 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h6><p>A事务在本次事务中对未操作的数据进行多次查询，发现第一次没有，第二次出现了就像幻觉一样。或者第一次有而第二次没有。针对delete和insert。</p>
<p><strong>案例</strong></p>
<p>楠哥的老婆在银行部门工作，她时常通过银行内部系统查看楠哥的账户信息。有一天，她正在查询到楠哥账户信息时发现楠哥只有一个账户，心想这家伙应该没有私房钱。此时楠哥在另外一家分行右开了一个账户，准备存私房钱。一次同时楠哥老婆点击了打印，结果打印出的楠哥账户居然多了一个，真实奇怪。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set  transaction isolation level repeatable read;</span><br></pre></td></tr></table></figure>

<p>1-楠哥开启事务</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start transaction;</span><br></pre></td></tr></table></figure>

<p>2-老婆查账户</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;楠哥&#x27;</span>;</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>3-楠哥趁机开户</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insert into user values(3,&#x27;楠哥&#x27;,10000);</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure>

<p>4-老婆再查询并打印，应该发现楠哥多了一个账户，但是没有。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where name = &#x27;楠哥&#x27;;</span><br></pre></td></tr></table></figure>

<p>MySQL 通过多版本并发控制（MVCC）（快照读&#x2F;一致性读）其实解决了幻读问题。</p>
<p>原理：事务开启后，将历史数据存一份快照，其他事务增加与删除的数据，对于当前事务来说是不可见的。</p>
<p>当然还能这样测一下</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set  transaction isolation level repeatable read;</span><br></pre></td></tr></table></figure>

<p>1-楠哥开启事务</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start transaction;</span><br></pre></td></tr></table></figure>

<p>2-老婆查账户，给楠哥开了个账户</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;楠哥&#x27;</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">&#x27;楠哥&#x27;</span>,<span class="number">10000</span>);</span><br></pre></td></tr></table></figure>

<p>3-楠哥不知道老婆给他开了账户，自己也开一个，看见自己没有这个3号账户，居然不能插入，很奇幻。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;楠哥&#x27;</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">&#x27;楠哥&#x27;</span>,<span class="number">10000</span>);</span><br></pre></td></tr></table></figure>

<h5 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h5><ul>
<li>事务A和事务B，事务A在操作数据库时，事务B只能排队等待</li>
<li>这种隔离级别很少使用，吞吐量太低，用户体验差</li>
<li>这种级别可以避免“幻像读”，每一次读取的都是数据库中真实存在数据，事务A与事务B串行，而不并发。</li>
<li>别的地方一用这个数据就不能修改删除，直到别的地方提交</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span>  transaction isolation level serializable;</span><br></pre></td></tr></table></figure>

<p>1-楠哥</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>

<p>2-老婆</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>

<p>3-楠哥操作发现卡住了</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">9</span>;</span><br></pre></td></tr></table></figure>

<p>4-老婆这边一提交，那边就能操作了</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>

<h2 id="Mysql的锁机制"><a href="#Mysql的锁机制" class="headerlink" title="Mysql的锁机制"></a>Mysql的锁机制</h2><ul>
<li>数据库锁机制简单来说，就是数据库为了保证数据的一致性，使各种<code>共享资源</code>在被访问时变得<code>有序而设计</code>的一种规则。</li>
<li>MysQL的锁机制比较简单最著的特点是不同的存储引擎支持不同的锁机制。 InoDB支持行锁,(有时也会升级为表锁）MyISAM只支持表锁。</li>
<li><code>表锁</code>的特点就是开销小、加锁快，不会出现死锁。锁粒度大，发生锁冲突的概率小，并发度相对低。</li>
<li><code>行锁</code>的特点就是开销大、加锁慢，会出现死锁。锁粒度小，发生锁冲突的概率高，并发度搞。</li>
<li>今天我们讲锁主要从InnoDB引擎来讲，因为它既支持行锁、也支持表锁。</li>
</ul>
<h4 id="InnoDB行锁的种类"><a href="#InnoDB行锁的种类" class="headerlink" title="InnoDB行锁的种类"></a>InnoDB行锁的种类</h4><p>InnoDB默认的事务隔离级别是RR，并且参数innodb_locks_unsafe_for_binling&#x3D;0的模式下，行锁有三种。</p>
<h5 id="记录锁（Record-Lock）"><a href="#记录锁（Record-Lock）" class="headerlink" title="记录锁（Record Lock）"></a>记录锁（Record Lock）</h5><p>（1）不加索引，两个事务修改同一行记录</p>
<p>事务一：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">update</span> teacher <span class="keyword">set</span> teacher_no <span class="operator">=</span> <span class="string">&#x27;T2010005&#x27;</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;wangsi&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>事务二：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">update</span> teacher <span class="keyword">set</span> teacher_no <span class="operator">=</span> <span class="string">&#x27;T2010006&#x27;</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;wangsi&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>发现卡住了：</p>
<p>事务一提交了，事务二才获取了。</p>
<p>（2）不加索引，两个事务修改同一表非同行记录</p>
<p>事务一：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">update</span> teacher <span class="keyword">set</span> teacher_no <span class="operator">=</span> <span class="string">&#x27;T2010005&#x27;</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;wangsi&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>事务二：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">update</span> teacher <span class="keyword">set</span> teacher_no <span class="operator">=</span> <span class="string">&#x27;T2010006&#x27;</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;wangsi&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>发现卡住了：</p>
<p>事务一提交了，事务二才获取了。</p>
<p>说明锁的是表！</p>
<p>（3）加索引，修改同一行记录，不行</p>
<p>事务一：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">update</span> teacher <span class="keyword">set</span> teacher_no <span class="operator">=</span> <span class="string">&#x27;T2010005&#x27;</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;wangsi&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>事务二：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">update</span> teacher <span class="keyword">set</span> teacher_no <span class="operator">=</span> <span class="string">&#x27;T2010006&#x27;</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;wangsi&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>发现卡住了：</p>
<p>事务一提交了，事务二才获取了。</p>
<p>（4）加索引，修改同表的不同行，可以修改</p>
<p>事务一：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">update</span> teacher <span class="keyword">set</span> teacher_no <span class="operator">=</span> <span class="string">&#x27;T2010008&#x27;</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;wangsi&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>事务二：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">update</span> teacher <span class="keyword">set</span> teacher_no <span class="operator">=</span> <span class="string">&#x27;T2010009&#x27;</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;jiangsi&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>发现都可一顺利修改，说明锁的的确是行。</p>
<p>证明行行锁是加在索引上的，这是标准的行级锁。</p>
<h5 id="间隙锁（GAP-Lock）"><a href="#间隙锁（GAP-Lock）" class="headerlink" title="间隙锁（GAP Lock）"></a>间隙锁（GAP Lock）</h5><p><code>在RR这个级别下</code>，为了避免幻读，引入了间隙锁，他锁定的是记录范围，不包含记录本身，也就是不允许在范围内插入数据。</p>
<p>根据检索条件向下寻找最靠近检索条件的记录值A作为左区间，向上寻找最靠近检索条件的记录值B作为右区间，即锁定的间隙为（A，B）。</p>
<p>查看隔离级别：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%iso%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>唯一索引 等值判断只会产生记录锁，范围查询会产生间隙锁</p>
<p>普通索引等值判断会产生间隙锁</p>
<p>第一步把teacher表的id的4改成8</p>
<p>事务一：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> teacher <span class="keyword">where</span> id <span class="operator">&lt;</span> <span class="number">6</span> lock <span class="keyword">in</span> share mode;</span><br></pre></td></tr></table></figure>

<p>事务二：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> teacher <span class="keyword">values</span> (<span class="number">5</span>,<span class="string">&#x27;zhangnan&#x27;</span>,<span class="string">&#x27;T888888&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>发现卡住了，因为他会把小于6的数据锁定，并不允许间隙中间的值插入：</p>
<p>事务三：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> teacher <span class="keyword">values</span> (<span class="number">9</span>,<span class="string">&#x27;huijun&#x27;</span>,<span class="string">&#x27;T66666666&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>发现成功了，因为9不在锁定的范围。</p>
<h5 id="记录锁和间隙锁的组合（next-key-lock）"><a href="#记录锁和间隙锁的组合（next-key-lock）" class="headerlink" title="记录锁和间隙锁的组合（next-key lock）"></a>记录锁和间隙锁的组合（next-key lock）</h5><p><strong>临键锁</strong>，是<strong>记录锁与间隙锁的组合</strong>，它的封锁范围，既包含索引记录，又包含索引区间。</p>
<p>**注：*<em>临键锁的主要目的，也是为了避免*<em>幻读</em></em>(Phantom Read)。如果把事务的隔离级别降级为RC，临键锁则也会失效。</p>
<h5 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h5><p>1、对于InnoDB表，在绝大部分情况下都应该使用行级锁，因为事务和行锁往往是我们之所以选择InnoDB表的理由。但在个另特殊事务中，也可以考虑使用表级锁。</p>
<ul>
<li>第一种情况是：事务需要更新大部分或全部数据，表又比较大，如果使用默认的行锁，不仅这个事务执行效率低，而且可能造成其他事务长时间锁等待和锁冲突，这种情况下可以考虑使用表锁来提高该事务的执行速度。</li>
<li>第二种情况是：事务涉及多个表，比较复杂，很可能引起死锁，造成大量事务回滚。这种情况也可以考虑一次性锁定事务涉及的表，从而避免死锁、减少数据库因事务回滚带来的开销。</li>
</ul>
<p>2、在InnoDB下 ，使用表锁要注意以下两点。</p>
<p>（１）使用LOCK TALBES虽然可以给InnoDB加表级锁，但必须说明的是，表锁不是由InnoDB存储引擎层管理的，而是由其上一层ＭySQL Server负责的，仅当autocommit&#x3D;0、innodb_table_lock&#x3D;1（默认设置）时，InnoDB层才能知道MySQL加的表锁，ＭySQL Server才能感知InnoDB加的行锁，这种情况下，InnoDB才能自动识别涉及表级锁的死锁；否则，InnoDB将无法自动检测并处理这种死锁。</p>
<p>（２）在用LOCAK TABLES对InnoDB锁时要注意，要将AUTOCOMMIT设为0，否则ＭySQL不会给表加锁；事务结束前，不要用UNLOCAK TABLES释放表锁，因为UNLOCK TABLES会隐含地提交事务；COMMIT或ROLLBACK不能释放用LOCAK TABLES加的表级锁，必须用UNLOCK TABLES释放表锁，正确的方式见如下语句。</p>
<p>例如，可以按如下做：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lock tables teacher write,student read;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> teacher;</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line">unlock tables;</span><br></pre></td></tr></table></figure>



<p>表锁的力度很大，慎用。</p>
<h4 id="InnoDB的锁类型"><a href="#InnoDB的锁类型" class="headerlink" title="InnoDB的锁类型"></a>InnoDB的锁类型</h4><p>InnoDB的锁类型主要有读锁(共享锁)、写锁(排他锁)、意向锁和MDL锁。</p>
<h5 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h5><p>读锁（共享锁，shared lock）简称S锁。一个事务获取了一个数据行的读锁，其他事务能获得该行对应的读锁但不能获得写锁，即一个事务在读取一个数据行时，其他事务也可以读，但不能对该数行增删改的操作。</p>
<blockquote>
<p>简而言之：就是可以多个事务读，但只能一个事务写。</p>
</blockquote>
<p>读锁有两种select方式的应用：</p>
<ol>
<li>第一种是自动提交模式下的select查询语句，不需加任何锁,直接返回查询结果，这就是一致性非锁定读。</li>
<li>第二种就是通过select…. lock in share mode被读取的行记录或行记录的范围上加一个读锁,让其他事务可以读,但是要想申请加写锁,那就会被阻塞。</li>
</ol>
<p>事务一：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span>  teacher <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> lock <span class="keyword">in</span> share mode;</span><br></pre></td></tr></table></figure>



<p>事务二：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">update</span> teacher <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;lucy2&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>



<p>卡住了，说明加了锁了。</p>
<h5 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h5><p>写锁，也叫排他锁，或者叫独占所，简称x锁。一个事务获取了一个数据行的写锁，其他事务就不能再获取该行的其他锁与锁优先级最高。</p>
<p>写锁的应用就很简单了，有以下两种情况：</p>
<blockquote>
<p>简而言之：就是只能有一个事务操作这个数据，别的事务都不行。</p>
</blockquote>
<p>（1）一些DML语句的操作都会对行记录加写锁。</p>
<p>事务一：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">update</span> teacher <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;lucy&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>



<p>事务二：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">update</span> teacher <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;lucy2&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>



<p>卡住了，说明加了锁了。</p>
<p>你发现他还能读，这是应为mysql实现了MVCC模型。</p>
<p>（2）比较特殊的就是select for update，它会对读取的行记录上加一个写锁，那么其他任何事务戴不能对被锁定的行上加任何锁了，要不然会被阻塞。</p>
<p>事务一：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span>  teacher <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>



<p>事务二：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">update</span> teacher <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;lucy2&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>



<p>卡住了，说明加了锁了。</p>
<p>你发现他还能读，这是应为mysql实现了MVCC模型。</p>
<h5 id="MDL锁"><a href="#MDL锁" class="headerlink" title="MDL锁"></a>MDL锁</h5><p>MySQL 5.5引入了meta data lock，简称MDL锁，用于保证表中<code>元数据</code>的信息。在会话A中，表开启了查询事务后，会自动获得一个MDL锁，会话B就不可以执行任何DDL语句，不能执行为表中添加字段的操作，会用MDL锁来保证数据之间的一致性。</p>
<p>元数据就是描述数据的数据，也就是你的表结构。意识是在你开启了事务之后获得了意向锁，其他事务就不能更改你的表结构。</p>
<h5 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h5><p>在mysql的innodb引擎中，意向锁是表级锁，意向锁有两种</p>
<p>意向共享锁（IS） 是指在给一个数据行加共享锁前必须获取该表的意向共享锁</p>
<p>意向排它锁（IX） 是指在给一个数据行加排他锁前必须获取该表的意向排他锁</p>
<p>意向锁和MDL锁都是为了防止在事务进行中，执行DDL语句导致数据不一致。</p>
<h4 id="从另一个角度区分锁的分类"><a href="#从另一个角度区分锁的分类" class="headerlink" title="从另一个角度区分锁的分类"></a>从另一个角度区分锁的分类</h4><h5 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h5><p>乐观锁大多是基于数据版本记录机制实现，一般是给数据库表增加一个”version”字段。读取数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。</p>
<p>比如下单操作：</p>
<p>查询出商品信息。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name, version <span class="keyword">from</span> teacher <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>根据商品信息生成订单。</p>
<p>将商品数量减1。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> teacher <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;lucy&#x27;</span>，version <span class="operator">=</span> version <span class="operator">+</span> <span class="number">1</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>  <span class="keyword">and</span> version <span class="operator">=</span>  <span class="number">3</span></span><br></pre></td></tr></table></figure>

<h5 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h5><p>总有刁民想害朕</p>
<p>悲观锁依靠数据库提供的锁机制实现。MySQL中的共享锁和排它锁都是悲观锁。数据库的增删改操作默认都会加排他锁，而查询不会加任何锁。此处不赘述。</p>
<h4 id="锁等待和死锁"><a href="#锁等待和死锁" class="headerlink" title="锁等待和死锁"></a>锁等待和死锁</h4><p>锁等待是指一个事务过程中产生的锁，其他事务需要等待上一个事务释放它的锁，才能占用该资源。如果该事务一直不释放，就需要持续等待下去，直到超过了锁等待时间，会报一个等待超时的错误。</p>
<p>MysQL中通过innodb_lock_wait_timeout参数控制,单位是秒。</p>
<blockquote>
<p>死锁的条件</p>
</blockquote>
<ol>
<li>两行记录，至少两个事务</li>
<li>事务A 操作 第n行数据，并加锁 <code>update teacher set name = &#39;a&#39; where id = 1;</code></li>
<li>事务B 操作 第m行数据，并加锁 <code>update teacher set name = &#39;b&#39; where id = 2;</code></li>
<li>事务A 操作 第m行数据 <code>update teacher set name = &#39;c&#39; where id = 2;</code></li>
<li>事务B 操作 第n行数据 <code>update teacher set name = &#39;d&#39; where id = 1;</code></li>
<li>形成死锁 <code>Deadlock found when trying to get lock; try restarting transaction</code></li>
</ol>
<p>死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，就是所谓的锁资源请求产生了回路现象，即死循环。</p>
<p>InnoDB引擎可以自动检测死锁并<code>回滚该事务</code>好不容易执行了一个业务给我回滚了，所以死锁尽量不要出现。</p>
<h4 id="如何避免死锁"><a href="#如何避免死锁" class="headerlink" title="如何避免死锁"></a>如何避免死锁</h4><ol>
<li>出现死锁并不可怕，但我们要尽量避免死锁</li>
<li>如果不同的程序会并发处理同一个表，或者涉及多行记录，尽量约定使用相同顺序访问表，可以大大减少死锁的发生。</li>
<li>业务中尽量采用小事务，避免使用大事务，要即使提交和回滚事务，可减少死锁产生的概率。</li>
<li>同一个事务中尽量做到一次锁定所需要的所有资源，减少死锁发生的概率。</li>
<li>对于非常容易发生死锁的业务，可以尝试使用升级锁的力度，该用表锁减少死锁的发生。</li>
</ol>
<h4 id="MVCC，多版本并发控制"><a href="#MVCC，多版本并发控制" class="headerlink" title="MVCC，多版本并发控制"></a>MVCC，多版本并发控制</h4><p>此章节本文转载至：<a target="_blank" rel="noopener" href="https://blog.csdn.net/SnailMann">https://blog.csdn.net/SnailMann</a> 的博客</p>
<p>**<code>MVCC</code>**，全称Multi-Version Concurrency Control，即多版本并发控制。MVCC是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。</p>
<p><strong>MVCC</strong>在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理读-写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读</p>
<hr>
<h5 id="什么是当前读和快照读？"><a href="#什么是当前读和快照读？" class="headerlink" title="什么是当前读和快照读？"></a>什么是当前读和快照读？</h5><p>在学习MVCC多版本并发控制之前，我们必须先了解一下，什么是MySQL InnoDB下的<code>当前读</code>和<code>快照读</code>?</p>
<ul>
<li><strong>当前读</strong> 像select lock in share mode(<code>共享锁</code>), select for update ; update, insert ,delete(<code>排他锁</code>)这些操作都是一种当前读，为什么叫当前读？就是它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁</li>
<li><strong>快照读</strong> 像不加锁的select操作就是快照读，即不加锁的非阻塞读；快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读；之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于多版本并发控制，即MVCC,可以认为MVCC是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；既然是基于多版本，即快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本</li>
</ul>
<p><strong>说白了MVCC就是为了实现读-写冲突不加锁，而这个读指的就是<code>快照读</code>, 而非当前读，当前读实际上是一种加锁的操作，是悲观锁的实现</strong></p>
<hr>
<h6 id="当前读，快照读和MVCC的关系"><a href="#当前读，快照读和MVCC的关系" class="headerlink" title="当前读，快照读和MVCC的关系"></a>当前读，快照读和MVCC的关系</h6><ul>
<li>准确的说，MVCC多版本并发控制指的是 <strong>“维持一个数据的多个版本，使得读写操作没有冲突”</strong> 这么一个概念。仅仅是一个理想概念</li>
<li>而在MySQL中，实现这么一个MVCC理想概念，<strong>我们就需要MySQL提供具体的功能去实现它，而快照读就是MySQL为我们实现MVCC理想模型的其中一个具体非阻塞读功能</strong>。而相对而言，当前读就是悲观锁的具体功能实现</li>
<li>要说的再细致一些，快照读本身也是一个抽象概念，再深入研究。MVCC模型在MySQL中的具体实现则是由 <strong><code>3个隐式字段</code><strong>，</strong><code>undo日志</code></strong> ，**<code>Read View</code>** 等去完成的，具体可以看下面的MVCC实现原理</li>
</ul>
<hr>
<h6 id="MVCC能解决什么问题"><a href="#MVCC能解决什么问题" class="headerlink" title="MVCC能解决什么问题"></a>MVCC能解决什么问题</h6><p><strong>数据库并发场景有三种，分别为：</strong></p>
<ul>
<li><code>读-读</code>：不存在任何问题，也不需要并发控制</li>
<li><code>读-写</code>：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读</li>
<li><code>写-写</code>：有线程安全问题，可能会存在更新丢失问题，比如第一类更新丢失，第二类更新丢失</li>
</ul>
<p><strong>MVCC带来的好处是？</strong> 多版本并发控制（MVCC）是一种用来解决<code>读-写冲突</code>的<strong>无锁并发控制</strong>，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。 所以MVCC可以为数据库解决以下问题</p>
<ul>
<li>在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能</li>
<li>同时还可以解决脏读，幻读，不可重复读等事务隔离问题，但不能解决更新丢失问题</li>
</ul>
<p><strong>小结一下咯</strong> 总之，MVCC就是因为大牛们，不满意只让数据库采用悲观锁这样性能不佳的形式去解决读-写冲突问题，而提出的解决方案，所以<strong>在数据库中，因为有了MVCC，所以我们可以形成两个组合：</strong></p>
<ul>
<li><code>MVCC + 悲观锁</code> MVCC解决读写冲突，悲观锁解决写写冲突</li>
<li><code>MVCC + 乐观锁</code> MVCC解决读写冲突，乐观锁解决写写冲突</li>
</ul>
<p>这种组合的方式就可以最大程度的提高数据库并发性能，并解决读写冲突，和写写冲突导致的问题</p>
<h6 id="MVCC的实现原理"><a href="#MVCC的实现原理" class="headerlink" title="MVCC的实现原理"></a>MVCC的实现原理</h6><hr>
<p>MVCC的目的就是多版本并发控制，在数据库中的实现，就是为了解决<code>读写冲突</code>，它的实现原理主要是依赖记录中的 <strong><code>3个隐式字段</code><strong>，</strong><code>undo日志</code></strong> ，**<code>Read View</code>** 来实现的。所以我们先来看看这个三个point的概念</p>
<blockquote>
<p>隐式字段</p>
</blockquote>
<p>每行记录除了我们自定义的字段外，还有数据库隐式定义的<code>DB_TRX_ID</code>,<code>DB_ROLL_PTR</code>,<code>DB_ROW_ID</code>等字段</p>
<ul>
<li>DB_TRX_ID 6byte，最近修改(修改&#x2F;插入)事务ID：记录创建这条记录&#x2F;最后一次修改该记录的事务ID</li>
<li>DB_ROLL_PTR 7byte，回滚指针，指向这条记录的上一个版本（存储于rollback segment里）</li>
<li>DB_ROW_ID 6byte，隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以DB_ROW_ID产生一个聚簇索引</li>
<li>实际还有一个删除flag隐藏字段, 既记录被更新或删除并不代表真的删除，而是删除flag变了</li>
</ul>
<p><img src="/2022/09/01/mysql/image-20211220190538714.4931715f.png" alt="image-20211220190538714"> 如上图，<code>DB_ROW_ID</code>是数据库默认为该行记录生成的唯一隐式主键，<code>DB_TRX_ID</code>是当前操作该记录的事务ID,而<code>DB_ROLL_PTR</code>是一个回滚指针，用于配合undo日志，指向上一个旧版本</p>
<hr>
<blockquote>
<p>undo日志</p>
</blockquote>
<p>undo log主要分为两种：</p>
<ul>
<li><strong>insert undo log</strong> 代表事务在<code>insert</code>新记录时产生的<code>undo log</code>, 只在事务回滚时需要，并且在事务提交后可以被立即丢弃</li>
<li><strong>update undo log</strong> 事务在进行<code>update</code>或<code>delete</code>时产生的<code>undo log</code>; 不仅在事务回滚时需要，在快照读时也需要；所以不能随便删除，只有在快速读或事务回滚不涉及该日志时，对应的日志才会被<code>purge</code>线程统一清除</li>
</ul>
<blockquote>
<p>purge线程，想成是一个环卫工人</p>
</blockquote>
<ul>
<li>从前面的分析可以看出，为了实现InnoDB的MVCC机制，更新或者删除操作都只是设置一下老记录的deleted_bit，并不真正将过时的记录删除。</li>
<li>为了节省磁盘空间，InnoDB有专门的purge线程来清理deleted_bit为true的记录。</li>
</ul>
<p>对MVCC有帮助的实质是update undo log，undo log实际上就是存旧记录链，<strong>它的执行流程如下：</strong></p>
<p>一、 比如persion表有一条记录，记录如下，<code>name</code>为Jerry, <code>age</code>为24岁，<code>隐式主键</code>是1，<code>事务ID</code>和<code>回滚指针</code>，我们假设为NULL</p>
<p><img src="/2022/09/01/mysql/image-20211220190550058.f54297a7.png" alt="image-20211220190550058"></p>
<p>二、 现在来了一个事务1对该记录的name做出了修改，改为Tom</p>
<ul>
<li>在事务1修改该行(记录)数据时，数据库会先对该行加排他锁</li>
<li>然后把该行数据拷贝到<code>undo log</code>中，作为旧记录，既在<code>undo log</code>中有当前行的拷贝副本</li>
<li>拷贝完毕后，修改该行<code>name</code>为Tom，并且修改隐藏字段的事务ID为当前<code>事务1</code>的ID, 我们默认从<code>1</code>开始，之后递增，回滚指针指向拷贝到<code>undo log</code>的副本记录，既表示我的上一个版本就是它</li>
<li>事务提交后，释放锁</li>
</ul>
<p><img src="/2022/09/01/mysql/image-20211220190610200.1ae5d427.png" alt="image-20211220190610200"></p>
<p>三、又来了个事务2修改person表的同一个记录，将<code>age</code>修改为30岁</p>
<ul>
<li>在<code>事务2</code>修改该行数据时，数据库也先为该行加锁</li>
<li>然后把该行数据拷贝到<code>undo log</code>中，作为旧记录，发现该行记录已经有<code>undo log</code>了，那么最新的旧数据作为链表的表头，插在该行记录的<code>undo log</code>最前面</li>
<li>修改该行<code>age</code>为30岁，并且修改隐藏字段的事务ID为当前<code>事务2</code>的ID, 那就是<code>2</code>，回滚指针指向刚刚拷贝到<code>undo log</code>的副本记录</li>
<li>事务提交，释放锁</li>
<li><img src="/2022/09/01/mysql/image-20211220190627964.143d9167.png" alt="image-20211220190627964"></li>
</ul>
<p>从上面，我们就可以看出，不同事务或者相同事务的对同一记录的修改，会导致该记录的<code>undo log</code>成为一条记录版本线性表，既链表，<code>undo log</code>的链首就是最新的旧记录，链尾就是最早的旧记录（<strong>当然就像之前说的该undo log的节点可能是会purge线程清除掉，向图中的第一条insert undo log，其实在事务提交之后可能就被删除丢失了，不过这里为了演示，所以还放在这里</strong>）</p>
<hr>
<h6 id="Read-View-读视图"><a href="#Read-View-读视图" class="headerlink" title="Read View(读视图)"></a>Read View(读视图)</h6><p>什么是Read View，说白了Read View就是事务进行<code>快照读</code>操作的时候生产的<code>读视图</code>(Read View)，在该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照，记录并维护系统当前活跃事务的ID（<strong>当每个事务开启时，都会被分配一个ID, 这个ID是递增的，所以最新的事务，ID值越大</strong>）</p>
<p>所以我们知道 <code>Read View</code>主要是用来做可见性判断的, 即当我们某个事务执行快照读的时候，对该记录创建一个 Read View 读视图，把它比作条件用来判断当前事务能够看到哪个版本的数据，既可能是当前最新的数据，也有可能是该行记录的<code>undo log</code>里面的某个版本的数据。</p>
<h4 id="Redo-log"><a href="#Redo-log" class="headerlink" title="Redo log"></a>Redo log</h4><p>MySQL数据库作为现在互联网公司内最流行的关系型数据库，相信大家都有工作中使用过。InnoDB是MySQL里最为常用的一种存储引擎，主要面向在线事务处理(OLTP)的应用。今天就让我们来探究一下InnoDB是如何一步一步实现事务的，这次我们先讲事务实现的redo log。</p>
<p>首先我们先明确一下InnoDB的修改数据的基本流程，当我们想要修改DB上某一行数据的时候，InnoDB是把数据从磁盘读取到内存的缓冲池上进行修改。数据在内存中被修改，与磁盘中相比就存在了差异，我们称这种有差异的数据为<strong>脏页</strong>。InnoDB对脏页的处理不是每次生成脏页就将脏页刷新回磁盘，这样会产生海量的IO操作，严重影响InnoDB的处理性能。对于此，InnoDB有一套完善的处理策略，与我们这次主题关系不大，表过不提。既然脏页与磁盘中的数据存在差异，那么如果在这期间DB出现故障就会造成数据的丢失。为了解决这个问题，redo log就应运而生了。</p>
<h5 id="Redo-log工作原理"><a href="#Redo-log工作原理" class="headerlink" title="Redo log工作原理"></a>Redo log工作原理</h5><p>在讲Redo log工作原理之前，先来学习一下MySQL的一些基础：</p>
<p><strong>一、日志类型</strong></p>
<p><img src="/2022/09/01/mysql/image-20211220190639970.d6e37914.png" alt="image-20211220190639970"></p>
<p>redo log在数据库重启恢复的时候被使用，因为其属于物理日志的特性，恢复速度远快于逻辑日志。而我们经常使用的binlog就属于典型的逻辑日志。</p>
<p><strong>二、 checkpoint</strong></p>
<p>坦白来讲checkpoint本身是比较复杂的，checkpoint所做的事就是把脏页给刷新回磁盘。所以，当DB重启恢复时，只需要恢复checkpoint之后的数据。这样就能大大缩短恢复时间。当然checkpoint还有其他的作用。</p>
<p><strong>三、 LSN(Log Sequence Number)</strong></p>
<p>LSN实际上就是InnoDB使用的一个版本标记的计数，它是一个单调递增的值。数据页和redo log都有各自的LSN。我们可以根据数据页中的LSN值和redo log中LSN的值判断需要恢复的redo log的位置和大小。</p>
<p><strong>四、 工作原理</strong></p>
<p>好的，现在我们来看看redo log的工作原理。说白了，redo log就是存储了数据被修改后的值。当我们提交一个事务时，InnoDB会先去把要修改的数据写入日志，然后再去修改缓冲池里面的真正数据页。</p>
<p>我们着重看看redo log是怎么一步步写入磁盘的。redo log本身也由两部分所构成即重做日志缓冲(redo log buffer)和重做日志文件(redo log file)。这样的设计同样也是为了调和内存与磁盘的速度差异。InnoDB写入磁盘的策略可以通过<code>innodb_flush_log_at_trx_commit</code>这个参数来控制。</p>
<p><img src="/2022/09/01/mysql/image-20211220190701788.1c09e00c.png" alt="image-20211220190701788"></p>
<p>当该值为1时，当然是最安全的，但是数据库性能会受一定影响。</p>
<p>为0时性能较好，但是会丢失掉master thread还没刷新进磁盘部分的数据。</p>
<p>这里我想简单介绍一下master thread，这是InnoDB一个在后台运行的主线程，从名字就能看出这个线程相当的重要。它做的主要工作包括但不限于：刷新日志缓冲，合并插入缓冲，刷新脏页等。master thread大致分为每秒运行一次的操作和每10秒运行一次的操作。master thread中刷新数据，属于checkpoint的一种。所以如果在master thread在刷新日志的间隙，DB出现故障那么将丢失掉这部分数据。</p>
<p>当该值为2时，当DB发生故障能恢复数据。但如果操作系统也出现宕机，那么就会丢失掉，文件系统没有及时写入磁盘的数据。</p>
<p>这里说明一下，<code>innodb_flush_log_at_trx_commit</code>设为非0的值，并不是说不会在master thread中刷新日志了。master thread刷新日志是在不断进行的，所以redo log写入磁盘是在持续的写入。</p>
<p><strong>五、 宕机恢复</strong></p>
<p>DB宕机后重启，InnoDB会首先去查看数据页中的LSN的数值。这个值代表数据页被刷新回磁盘的LSN的大小。然后再去查看redo log的LSN的大小。如果数据页中的LSN值大说明数据页领先于redo log刷新回磁盘，不需要进行恢复。反之需要从redo log中恢复数据。</p>
<h2 id="Mysql主从同步"><a href="#Mysql主从同步" class="headerlink" title="Mysql主从同步"></a>Mysql主从同步</h2><hr>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>指一台服务器充当主数据库服务器，另一台或多台服务器充当从数据库服务器，主服务器中的数据自动复制到从服务器之中。对于多级复制，数据库服务器即可充当主机，也可充当从机。</p>
<p>MySQL主从复制的基础是<strong>主服务器对数据库修改记录二进制日志</strong>，从服务器通过主服务器的二进制日志自动执行更新。 一句话表示就是，主数据库做什么，从数据库就跟着做什么。</p>
<h3 id="主从复制工作原理剖析"><a href="#主从复制工作原理剖析" class="headerlink" title="主从复制工作原理剖析"></a>主从复制工作原理剖析</h3><ul>
<li>Master 数据库只要发生变化，立马记录到Binary log 日志文件中</li>
<li>Slave数据库启动一个I&#x2F;O thread连接Master数据库，请求Master变化的二进制日志</li>
<li>Slave I&#x2F;O获取到的二进制日志，保存到自己的Relay log 日志文件中。</li>
<li>Slave 有一个 SQL thread定时检查Realy log是否变化，变化那么就更新数据</li>
</ul>
<p><img src="/2022/09/01/mysql/image-20201211164642229.abb459d2.png" alt="image-20201211164642229"></p>
<h3 id="为什么要用mysql-的主从"><a href="#为什么要用mysql-的主从" class="headerlink" title="为什么要用mysql 的主从"></a>为什么要用mysql 的主从</h3><hr>
<h4 id="实现服务器负载均衡"><a href="#实现服务器负载均衡" class="headerlink" title="实现服务器负载均衡"></a><strong>实现服务器负载均衡</strong></h4><p> 即可以通过在主服务器和从服务器之间切分处理客户查询的负荷，从而得到更好的客户相应时间。通常情况下，数据库管理员会有两种思路。</p>
<p> 一是在主服务器上只实现数据的更新操作。包括数据记录的更新、删除、新建等等作业。而不关心数据的查询作业。数据库管理员将数据的查询请求全部 转发到从服务器中。这在某些应用中会比较有用。如某些应用，像基金净值预测的网站。其数据的更新都是有管理员更新的，即更新的用户比较少。而查询的用户数 量会非常的多。此时就可以设置一台主服务器，专门用来数据的更新。同时设置多台从服务器，用来负责用户信息的查询</p>
<p> 二是在主服务器上与从服务器切分查询的作业。在这种思路下，主服务器不单单要完成数据的更新、删除、插入等作业，同时也需要负担一部分查询作业。而从服务器的话，只负责数据的查询。当主服务器比较忙时，部分查询请求会自动发送到从服务器重，以降低主服务器的工作负荷。</p>
<h4 id="通过复制实现数据的异地备份"><a href="#通过复制实现数据的异地备份" class="headerlink" title="通过复制实现数据的异地备份"></a><strong>通过复制实现数据的异地备份</strong></h4><p> 可以定期的将数据从主服务器上复制到从服务器上，这无疑是先了数据的异地备份。在传统的备份体制下，是将数据备份在本地。此时备份 作业与数据库服务器运行在同一台设备上，当备份作业运行时就会影响到服务器的正常运行。有时候会明显的降低服务器的性能。同时，将备份数据存放在本地，也 不是很安全。如硬盘因为电压等原因被损坏或者服务器被失窃，此时由于备份文件仍然存放在硬盘上，数据库管理员无法使用备份文件来恢复数据。这显然会给企业 带来比较大的损失。</p>
<h4 id="提高数据库系统的可用性"><a href="#提高数据库系统的可用性" class="headerlink" title="提高数据库系统的可用性"></a><strong>提高数据库系统的可用性</strong></h4><p> 数据库复制功能实现了主服务器与从服务器之间数据的同步，增加了数据库系统的可用性。当主服务器出现问题时，数据库管理员可以马上让从服务器作为主服务器，用来数据的更新与查询服务。然后回过头来再仔细的检查主服务器的问题。此时一般数据库管理员也会采用两种手段。</p>
<p> 一是主服务器故障之后，虽然从服务器取代了主服务器的位置，但是对于主服务器可以采取的操作仍然做了一些限制。如仍然只能够进行数据的查询，而 不能够进行数据的更新、删除等操作。这主要是从数据的安全性考虑。如现在一些银行系统的升级，在升级的过程中，只能够查询余额而不能够取钱。这是同样的道 理。</p>
<p> 二是从服务器真正变成了主服务器。当从服务器切换为主服务器之后，其地位完全与原先的主服务器相同。此时可以实现对数据的查询、更新、删除等操 作。为此就需要做好数据的安全性工作。即数据的安全策略，要与原先的主服务器完全相同。否则的话，就可能会留下一定的安全隐患</p>
<h3 id="怎么配置mysql主从复制"><a href="#怎么配置mysql主从复制" class="headerlink" title="怎么配置mysql主从复制"></a>怎么配置mysql主从复制</h3><hr>
<h4 id="环境准环境准备"><a href="#环境准环境准备" class="headerlink" title="环境准环境准备"></a>环境准环境准备</h4><p>本地安装两个mysql，或者使用虚拟机，需要准备两个mysql，</p>
<p>环境，可以使伪集群，也可以是真集群</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql1(master): 192.168.120.200:3306</span><br><span class="line">mysql2(slave):  192.168.120.201:3306</span><br></pre></td></tr></table></figure>

<h4 id="配置文件配置"><a href="#配置文件配置" class="headerlink" title="配置文件配置"></a>配置文件配置</h4><p>mysql1(master): 配置文件设置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#mysql master1 config </span></span><br><span class="line">[mysqld]</span><br><span class="line">server-id = 1        <span class="comment"># 节点ID，确保唯一</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># log config</span></span><br><span class="line">log-bin = master-bin     <span class="comment">#开启mysql的binlog日志功能</span></span><br><span class="line">sync_binlog = 1         <span class="comment">#控制数据库的binlog刷到磁盘上去 , 0 不控制，性能最好，1每次事物提交都会刷到日志文件中，性能最差，最安全</span></span><br><span class="line">binlog_format = mixed   <span class="comment">#binlog日志格式，mysql默认采用statement，建议使用mixed</span></span><br><span class="line">expire_logs_days = 7                           <span class="comment">#binlog过期清理时间</span></span><br><span class="line">max_binlog_size = 100m                    <span class="comment">#binlog每个日志文件大小</span></span><br><span class="line">binlog_cache_size = 4m                        <span class="comment">#binlog缓存大小</span></span><br><span class="line">max_binlog_cache_size= 512m              <span class="comment">#最大binlog缓存大</span></span><br><span class="line">binlog-ignore-db=mysql <span class="comment">#不生成日志文件的数据库，多个忽略数据库可以用逗号拼接，或者 复制这句话，写多行</span></span><br><span class="line"></span><br><span class="line">auto-increment-offset = 1     <span class="comment"># 自增值的偏移量</span></span><br><span class="line">auto-increment-increment = 1  <span class="comment"># 自增值的自增量</span></span><br><span class="line">slave-skip-errors = all        <span class="comment">#跳过从库错误</span></span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17</p>
<p>mysql2(slave): 201 mysql.cnf 配置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">server-id=2</span><br><span class="line">log-bin=mysql-bin</span><br><span class="line">relay-log=mysql-relay-bin</span><br><span class="line">replicate-wild-ignore-table=mysql.%</span><br><span class="line">replicate-wild-ignore-table=<span class="built_in">test</span>.%</span><br><span class="line">replicate-wild-ignore-table=information_schema.%</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7</p>
<p>重启两个mysql，让配置生效</p>
<h4 id="master数据库，创建复制用户并授权"><a href="#master数据库，创建复制用户并授权" class="headerlink" title="master数据库，创建复制用户并授权"></a>master数据库，创建复制用户并授权</h4><p>1.进入master的数据库，为master创建复制用户</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER repl IDENTIFIED BY <span class="string">&#x27;Root12345_&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>1</p>
<p>2.赋予该用户复制的权利</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grant replication slave <span class="keyword">on</span> *.* to <span class="string">&#x27;repl&#x27;</span>@<span class="string">&#x27;192.168.120.200&#x27;</span>  identified <span class="keyword">by</span> <span class="string">&#x27;Root12345_&#x27;</span>;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>

<p>1<br>2</p>
<p>3.查看master的状态</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">show master status;</span><br><span class="line">mysql&gt; show master status;</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">|<span class="params"> File             </span>| Position |<span class="params"> Binlog_Do_DB </span>| Binlog_Ignore_DB |<span class="params"> Executed_Gtid_Set </span>|</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">|<span class="params"> mysql-bin.000005      120</span>|              |<span class="params"> mysql            </span>|                   |<span class="params"></span></span><br><span class="line"><span class="params">+------------------+----------+--------------+------------------+-------------------+</span></span><br><span class="line"><span class="params">1 row <span class="keyword">in</span> set (0.00 sec)</span></span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8</p>
<p>4,配置从库</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CHANGE MASTER TO </span><br><span class="line">MASTER_HOST = <span class="string">&#x27;192.168.120.200&#x27;</span>,  </span><br><span class="line">MASTER_USER = <span class="string">&#x27;repl&#x27;</span>, </span><br><span class="line">MASTER_PASSWORD = <span class="string">&#x27;Root12345_&#x27;</span>,</span><br><span class="line">MASTER_PORT = 3306,</span><br><span class="line">MASTER_LOG_FILE=<span class="string">&#x27;master-bin.000001&#x27;</span>,</span><br><span class="line">MASTER_LOG_POS=120,</span><br><span class="line">MASTER_RETRY_COUNT = 60,</span><br><span class="line">MASTER_HEARTBEAT_PERIOD = 10000; </span><br><span class="line"></span><br><span class="line"><span class="comment"># MASTER_LOG_FILE与主库File 保持一致</span></span><br><span class="line"><span class="comment"># MASTER_LOG_POS=120 , #与主库Position 保持一致</span></span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12</p>
<p>启动从库slave进程</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; slave start;</span><br><span class="line">Query OK, <span class="number">0</span> rows affected (<span class="number">0.04</span> sec)</span><br></pre></td></tr></table></figure>

<p>1<br>2</p>
<p>查看是否配置成功</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 主库添加一条数据</span></span><br><span class="line"><span class="comment">-- 从库查询</span></span><br></pre></td></tr></table></figure>

<p>1<br>2</p>
<h3 id="可能遇到的问题可能遇到的问题"><a href="#可能遇到的问题可能遇到的问题" class="headerlink" title="可能遇到的问题可能遇到的问题"></a>可能遇到的问题可能遇到的问题</h3><blockquote>
<p>在配置mysql主从复制的时候出现错误：</p>
</blockquote>
<p>Fatal error: The slave I&#x2F;O thread stops because master and slave have equal MySQL server UUIDs; these UUIDs must be different for replication to work.</p>
<h4 id="现象现象"><a href="#现象现象" class="headerlink" title="现象现象"></a>现象现象</h4><p><img src="/2022/09/01/mysql/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTAyNTM2Mg==,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"> Slave_IO_Running:No，mysql的IO线程没有正常工作</p>
<h5 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h5><p>笔者使用两台虚拟机，一主一从，从库的mysql是直接克隆的。在mysql 5.6的复制引入了uuid的概念，各个复制结构中的server_uuid得保证不一样，但是查看到直接克隆data文件夹后server_uuid是相同的。</p>
<h5 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h5><p>找到data文件夹下的auto.cnf文件，修改里面的server_uuid值，保证各个db的server_uuid不一样，重启db即可。 找出auto.cnf</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name <span class="string">&#x27;auto.cnf&#x27;</span></span><br></pre></td></tr></table></figure>

<p>修改server_uuid的值</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /var/lib/mysql/auto.cnf</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> uuid();</span><br></pre></td></tr></table></figure>

<p>生成一个uuid即可。</p>
<p>重启数据库即可。</p>
<h2 id="存储过程和函数"><a href="#存储过程和函数" class="headerlink" title="存储过程和函数"></a>存储过程和函数</h2><h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><p>与表有关的数据对象，在满足某种条件的时候，被动执行的SQL语句。</p>
<h4 id="触发器的特性触发器的特性"><a href="#触发器的特性触发器的特性" class="headerlink" title="触发器的特性触发器的特性"></a>触发器的特性触发器的特性</h4><ol>
<li>有begin、end的结构体（多条sql语句）</li>
<li>需要指定触发的条件：INSERT，UPDATE，DELETE</li>
<li>有指定的触发时间：BEFORE，AFTER</li>
</ol>
<h4 id="触发器的创建"><a href="#触发器的创建" class="headerlink" title="触发器的创建"></a>触发器的创建</h4><ul>
<li>单条业务逻辑的触发器创建</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">CREATE TRIGGER 触发器名称 BEFORE|AFTER INSERT|UPDATE|DELETE ON 表名</span><br><span class="line">FOR EACH ROW 业务逻辑</span><br><span class="line">*/</span><br><span class="line">#当b_user表中插入数据后，b_log表中也插入一条数据</span><br><span class="line">CREATE TRIGGER trigger_insert AFTER INSERT ON b_user</span><br><span class="line">FOR EACH ROW INSERT INTO b_log(字段) VALUES(&#x27;插入数据&#x27;)</span><br></pre></td></tr></table></figure>

<ul>
<li>多条业务逻辑的触发器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">DELIMITER $</span><br><span class="line">CREATE TRIGGER 触发器名称 BEFORE|AFTER INSERT|UPDATE|DELETE ON 表名</span><br><span class="line">FOR EACH ROW</span><br><span class="line">BIGIN</span><br><span class="line">INSERT...;</span><br><span class="line">UPDATE...;</span><br><span class="line">END;$</span><br><span class="line">*/</span><br><span class="line">#在b_user表中插入数据前，b_log表中插入2条数据</span><br><span class="line">DELIMITER $</span><br><span class="line">CREATE TRIGGER trigger_ insert_before BEFORE INSERT ON b_user</span><br><span class="line">FOR EACH ROW</span><br><span class="line">BEGIN</span><br><span class="line">INSERT INTO b_log(comments,name) values(&#x27;insert1&#x27; ，NEW.name);</span><br><span class="line">INSERT INTO b_log(comments,name) values(&#x27;insert2&#x27; , NEW.name) ;</span><br><span class="line">END;$</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17</p>
<p><strong>总结</strong></p>
<ul>
<li>BEFORE|AFTER INSERT用于获取将要插入的数据</li>
<li>BEFORE|AFTER UPDATE|DELETE用于获取已经修改或删除的数据</li>
</ul>
<h4 id="删除触发器删除触发器"><a href="#删除触发器删除触发器" class="headerlink" title="删除触发器删除触发器"></a>删除触发器删除触发器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TRIGGER 触发器名称</span><br></pre></td></tr></table></figure>

<h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><h5 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h5><p>由mysql数据库管理系统提供的，变量名称固定，可以修改和查看值，分为<strong>全局变量</strong>和<strong>会话变量</strong></p>
<p><strong>全局变量</strong>：当mysql服务没有重启时，我们可以查看和修改的变量</p>
<p><strong>会话变量</strong>：和MySQL连接形成的会话，生命周期在整个会话过程中</p>
<p>全局变量用global修饰，会话变量用session修饰，通常session可以省略</p>
<ul>
<li>查看系统变量</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SHOW GLOBAL variables; -- 查看全局变量</span><br><span class="line">SHOW SESSION variables; -- 查看会话变量</span><br><span class="line">SHOW variables; -- 查看会话变量</span><br><span class="line">SHOW GLOBAL variables like &#x27;%dir%&#x27;; -- 模糊查询环境变量</span><br><span class="line">SELECT @@datadir; -- 查看全局系统变量</span><br><span class="line">SELECT @@session_track_transaction_info;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改系统变量</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SHOW GLOBAL variables like &#x27;autocommit&#x27;; -- 全局系统变量中为自动提交事务</span><br><span class="line">SET GLOBAL autocommit=0; -- 将全局的自动提交的事务改为手动提交</span><br><span class="line">SHOW SESSION variables link &#x27;autocommit&#x27;; -- 查看会话变量中自动提交事务</span><br><span class="line">SET SESSION autocommit=0; -- 将会话变量中自动提交的事务改为手动提交</span><br><span class="line">SET @@session.autocommit=1;</span><br><span class="line">SET @@global.autocommit=1;</span><br></pre></td></tr></table></figure>

<p><strong>全局变量</strong>在修改后，在不同的会话中都会立即生效，但是在重新启动mysql服务后，全局变量会恢复为默认值，如果想让全局变量依旧有效，需要去修改.ini文件（MySQL配置文件）</p>
<p><strong>会话变量</strong>在修改后只对当前会话有效。一般在开发过程中修改会话变量。如：字符编码格式等可以在ini文件中进行设置</p>
<h5 id="用户变量用户变量"><a href="#用户变量用户变量" class="headerlink" title="用户变量用户变量"></a>用户变量用户变量</h5><p>MySQL允许用户自定义变量，分为用户变量和局部变量</p>
<ul>
<li><p>用户变量</p>
<p>作用域：当前会话有效</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#设置方式1，先去声明并初始化用户变量，赋值操作既可以使用=进行赋值，也可以使用:=进行赋值</span><br><span class="line">SET @变量名=值;</span><br><span class="line">SET @变量名:=值;</span><br><span class="line">SELECT @变量名:=值;</span><br><span class="line">#设置方式2</span><br><span class="line">SELECT 字段 into @变量名 FROM 表名;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6</p>
</li>
<li><p>局部变量</p>
<p>作用域：在begin end的结构体中，声明必须是begin end结构体的第一句</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#声明方式，必须在begin后面从第一行开始</span><br><span class="line">DECLARE 变量名 类型;</span><br><span class="line">DECLARE 变量名 类型 DEFAULT 值;</span><br><span class="line"></span><br><span class="line">#局部变量的赋值</span><br><span class="line">SET 变量名:=值;</span><br><span class="line">SELECT @变量名:=值;</span><br><span class="line">SELECT 字段 into 变量名 FROM 表名;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="存储过程的创建存储过程的创建"><a href="#存储过程的创建存储过程的创建" class="headerlink" title="存储过程的创建存储过程的创建"></a>存储过程的创建存储过程的创建</h4><p>存储过程是一组已经预先编译好的sql语句的集合，理解为批处理语句（增加流程控制语句），一般在复杂逻辑中才会使用存储过程</p>
<ul>
<li><p>存储过程的优点</p>
<ul>
<li>提供了代码的可用性</li>
<li>简化了数据库操作，将业务逻辑的细节隐藏在存储过程中</li>
<li>减少了编译次数，减少了网络IO的次数，从而提高操作效率</li>
</ul>
</li>
<li><p>存储过程的创建</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">DELIMITER $</span><br><span class="line">CREATE PROCEDURE 存储过程的名称(参数列表)</span><br><span class="line">BEGIN</span><br><span class="line">局部变量的定义</span><br><span class="line">多条sql语句</span><br><span class="line">流程控制语句</span><br><span class="line">END;$</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p>如果存储过程中只有一条SQL语句可以省略BEGIN END</p>
<p>参数列表</p>
<table>
<thead>
<tr>
<th>参数模式</th>
<th>形参名称</th>
<th>参数类型</th>
</tr>
</thead>
<tbody><tr>
<td>IN</td>
<td>username</td>
<td>mysql数据库中的数据类型（数值型，字符型，日期型）</td>
</tr>
<tr>
<td>OUT</td>
<td>pwd</td>
<td>mysql数据库中的数据类型（数值型，字符型，日期型）</td>
</tr>
<tr>
<td>INOUT</td>
<td>xxx</td>
<td>mysql数据库中的数据类型（数值型，字符型，日期型）</td>
</tr>
</tbody></table>
<p>IN：声明该参数是一个输入姓参数（类似于java中的形参）</p>
<p>OUT：声明该参数为一个输出型参数（类似于java中的返回值），在一个存储过程中可以定义多个out类型的参数</p>
<p>INOUT：声明该参数可以为输入型参数，也可以为输出型参数</p>
<ul>
<li><p>存储过程调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CALL 存储过程的名称(实参列表) </span><br><span class="line">-- 实参列表中包含由输出类型的参数</span><br></pre></td></tr></table></figure>

<p>1<br>2</p>
</li>
<li><p>存储过程演示</p>
<ul>
<li><p>无参的存储过程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#用于向b_user表中插入2条数据</span><br><span class="line">DELIMITER $</span><br><span class="line">CREATE PROCEDURE pro_insert()</span><br><span class="line">BEGIN</span><br><span class="line">INSERT INTO b_user(name,sex) VALUES(&#x27;1&#x27;,&#x27;1&#x27;);</span><br><span class="line">INSERT INTO b_user(name,sex) VALUES(&#x27;2&#x27;,&#x27;2&#x27;);</span><br><span class="line">END;$</span><br><span class="line"></span><br><span class="line">CALL pro_insert();</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9</p>
</li>
<li><p>带有IN模式参数的存储过程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#用于向b_user插入2条数据，性别由客户输入</span><br><span class="line">DELIMITER $</span><br><span class="line">CREATE PROCEDURE pro_insert2(IN sex CHAR(1))</span><br><span class="line">BEGIN</span><br><span class="line">INSERT INTO b_user(name,sex) VALUES(&#x27;1&#x27;,sex);</span><br><span class="line">INSERT INTO b_user(name,sex) VALUES(&#x27;2&#x27;,sex);</span><br><span class="line">END;$</span><br><span class="line"></span><br><span class="line">CALl pro_insert2(&#x27;男&#x27;);</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9</p>
</li>
<li><p>多个带有IN参数的存储过程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#用于向b_user插入2条数据，用户名和密码由客户输入</span><br><span class="line">DELIMITER $</span><br><span class="line">CREATE PROCEDURE pro_insert3(IN name VARCHAR(10),IN sex VARCHAR(20))</span><br><span class="line">BEGIN</span><br><span class="line">INSERT INTO b_user(name,sex) VALUES(name,sex);</span><br><span class="line">INSERT INTO b_user(name,sex) VALUES(name,sex);</span><br><span class="line">END;$</span><br><span class="line"></span><br><span class="line">CALL pro_insert2(&#x27;uname&#x27;,&#x27;男&#x27;);</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9</p>
</li>
<li><p>带IN，OUT参数的存储过程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#判断用户登录，如果用户名和密码输入正确登录成功，否则登录失败</span><br><span class="line">#根据输入的用户名和密码作为条件去b_user表中查询，如果查询总行数==1，则认为登录成功，让result返回登录成功，否则登录失败</span><br><span class="line">DELIMITER $</span><br><span class="line">CREATE PROCEDURE pro_login(IN name VARCHAR(20),IN pwd VARCHAR(20),OUT result VARCHAR(20))</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE total INT DEFAULT 0;-- 用于存放查询总行数</span><br><span class="line">select count(*) from b_user u where u.name=name and u.pwd=pwd;-- 将查询结果赋值给total局部变量</span><br><span class="line">SET result:=IF(total=1,&#x27;登录成功&#x27;,&#x27;登录失败&#x27;);</span><br><span class="line">END;$</span><br><span class="line">#存储过程如何执行</span><br><span class="line">-- 解决判断，使用自定义变量</span><br><span class="line">SET @result:=&#x27;&#x27;;</span><br><span class="line">CAll pro_login(&#x27;李四&#x27;,&#x27;123&#x27;,@result);</span><br><span class="line">select @result;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14</p>
</li>
<li><p>删除存储过程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP PROCEDURE 存储过程名称</span><br></pre></td></tr></table></figure>

<p>1</p>
</li>
<li><p>查看存储过程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW CREATE PROCEDURE 存储过程名称;</span><br></pre></td></tr></table></figure>

<p>1</p>
</li>
<li><p>修改存储过程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DROP</span><br><span class="line">CREATE</span><br></pre></td></tr></table></figure>

<p>1<br>2</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h4><blockquote>
<p>选择结构</p>
</blockquote>
<ul>
<li><p>IF函数</p>
<ul>
<li>功能：三目运算</li>
<li>语法：IF(逻辑表达式，表达式1，表达式2)</li>
</ul>
</li>
<li><p>IF结构</p>
<ul>
<li><p>功能：实现多路选择</p>
</li>
<li><p>注意：只能用在BEGIN END结构体中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">IF 逻辑表达式 THEN 语句1;</span><br><span class="line">ELSEIF 逻辑表达式2 THEN 语句2;</span><br><span class="line">...</span><br><span class="line">ELSE 语句n;</span><br><span class="line">END IF;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>CASE结构</p>
<ul>
<li>等值选择</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CASE 字段|变量|表达式</span><br><span class="line">WHEN 值 THEN 值|语句</span><br><span class="line">WHEN 值 THEN 值</span><br><span class="line">...</span><br><span class="line">ELSE 值</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<ul>
<li>不等值选择</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CASE</span><br><span class="line">WHEN 逻辑表达式 THEN 语句1</span><br><span class="line">...</span><br><span class="line">ELSE 语句n</span><br><span class="line">END</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>循环结构</p>
</blockquote>
<ul>
<li><p>WHILE</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">WHILE 逻辑表达式 DO</span><br><span class="line">循环体</span><br><span class="line">END WHILE;</span><br><span class="line">*/</span><br><span class="line">#需求：创建存储过程，输入一个值，返回1到该值的和</span><br><span class="line">#分析：一个输入参数，一个返回值，在结构体中，从1循环到输入的值，求和</span><br><span class="line">DELIMITER //</span><br><span class="line">CREATE PROCEDURE pro_sum(IN input INT,OUT total INT)</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE i INT DEFAULT 1;</span><br><span class="line">DECLARE sum_ INT DEFAULT 0;</span><br><span class="line">WHILE i&lt;=input do</span><br><span class="line">SET sum_=sum_+i;</span><br><span class="line">SET i=i+1;</span><br><span class="line">END WHILE;</span><br><span class="line">SET totle:=sum_;</span><br><span class="line">END;//</span><br><span class="line"></span><br><span class="line">SET @result=0;</span><br><span class="line">CALL por_sun(10,@result);</span><br><span class="line">SELECT @result;</span><br></pre></td></tr></table></figure>
</li>
<li><p>LOOP</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#Loopnaem是定义的循环名称，为了跳出循环时指定跳出的循环</span><br><span class="line">loopname:LOOP;</span><br><span class="line">	IF 逻辑表达式 THEN</span><br><span class="line">	LEAVE loopname; -- 跳出当前指定的循环，类似于java中的break</span><br><span class="line">	END IF;</span><br><span class="line">END LOOP;</span><br><span class="line"></span><br><span class="line">DElIMITER //</span><br><span class="line">CREATE PROCEDURE pro_sum_loop(IN input INT,OUT total INT)</span><br><span class="line">BEGIN </span><br><span class="line">DECLARE i INT DEFAULT 1;</span><br><span class="line">DECLARE sum_ INT DEFAULT 0;</span><br><span class="line">a:LOOP;</span><br><span class="line">SET sum_:=sum_+i;</span><br><span class="line">SET i:=i+1;</span><br><span class="line">IF i&gt;input THEN</span><br><span class="line">LEAVE a;</span><br><span class="line">END IF;</span><br><span class="line">END LOOP;</span><br><span class="line">SET total:=sum_;</span><br><span class="line">END;//</span><br><span class="line"></span><br><span class="line">SET @result=0;</span><br><span class="line">CALL por_sum_loop(10,@result);</span><br><span class="line">SELECT @result;</span><br></pre></td></tr></table></figure>


</li>
<li><p>REPEAT</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">REPEAT</span><br><span class="line">循环体</span><br><span class="line">UNTIL 逻辑表达式 -- 当满足逻辑表达式，跳出循环</span><br><span class="line">END REPEAT;</span><br><span class="line"></span><br><span class="line">DELIMITER //</span><br><span class="line">CREATE PROCEDURE pro_sum_loop(IN input INT,OUT total INT)</span><br><span class="line">BEGIN </span><br><span class="line">DECLARE i INT DEFAULT 1;</span><br><span class="line">DECLARE sum_ INT DEFAULT 0;</span><br><span class="line">REPEAT</span><br><span class="line">SET sum_:=sum_+i;</span><br><span class="line">SET i:=i+1</span><br><span class="line">UNTIL i&gt;input</span><br><span class="line">END REPEAT;</span><br><span class="line">SET total:=sum_;</span><br><span class="line">END;//</span><br><span class="line"></span><br><span class="line">SET @result=0;</span><br><span class="line">CALL por_sum_loop(10,@result);</span><br><span class="line">SELECT @result;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h3><p>函数也是一组预先编译好的sql的集合，基本和存储过程相似</p>
<p><strong>函数和存储过程的区别</strong></p>
<ol>
<li>存储过程可以有0个，1个或多个返回值，适用于insert、update、delete操作</li>
<li>函数只能有一个返回值，适用于在处理数据以后，返回一个已知的结果</li>
</ol>
<h4 id="创建函数"><a href="#创建函数" class="headerlink" title="创建函数"></a>创建函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE FUNCTION 函数名称(参数列表) RETURNS 返回类型 BINLOG参数</span><br><span class="line">BEGIN</span><br><span class="line">函数体</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<p><strong>参数列表</strong>：参数名称 参数类型</p>
<p><strong>BINLOG参数</strong></p>
<ul>
<li>NO SQL：函数体中没有sql语句， 也不会改参数</li>
<li>READS SQL DATE：函数体中存在sql语句，但是整个数据是只读的，不会修改数据</li>
<li>MODIFIES SQL DATE ：函数体中存在SQL语句，并且会修改数据</li>
<li>CONTAINS SQL：函数体中包含有SQL语句</li>
</ul>
<p><strong>函数体</strong>：在函数体汇总必须包含return语句，将return放在函数体最后一行执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#写一个函数，用于求两数之和</span><br><span class="line">DELIMITER //</span><br><span class="line">CREATE FUNCTION sum_(input1 INT,input2 INT) RETURNS INT NO SQL</span><br><span class="line">BEGIN</span><br><span class="line">return input1+input2;</span><br><span class="line">END;//</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6</p>
<h4 id="使用函数"><a href="#使用函数" class="headerlink" title="使用函数"></a>使用函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 函数名(参数列表);</span><br></pre></td></tr></table></figure>

<p>1</p>
<h4 id="查看函数"><a href="#查看函数" class="headerlink" title="查看函数"></a>查看函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW CREATE FUNCTION 函数名;</span><br></pre></td></tr></table></figure>

<h4 id="删除函数"><a href="#删除函数" class="headerlink" title="删除函数"></a>删除函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP FUNCTION 函数名;</span><br></pre></td></tr></table></figure>

<h4 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h4><h4 id="查看定时策略是否开启"><a href="#查看定时策略是否开启" class="headerlink" title="查看定时策略是否开启"></a>查看定时策略是否开启</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%event_sche%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>开启定时策略：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> event_scheduler<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h4 id="创建定时任务创建定时任务"><a href="#创建定时任务创建定时任务" class="headerlink" title="创建定时任务创建定时任务"></a>创建定时任务创建定时任务</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> event run_event</span><br><span class="line"><span class="keyword">on</span> schedule <span class="keyword">every</span> <span class="number">1</span> <span class="keyword">minute</span></span><br><span class="line"><span class="keyword">on</span> completion preserve disable</span><br><span class="line">do <span class="keyword">call</span> test_procedure ();</span><br></pre></td></tr></table></figure>

<p>1、create event day_event：是创建名为run_event的事件 2、创建周期定时的规则，意思是每分钟执行一次 3、on completion preserve disable是表示创建后并不开始生效。 4、do call test_procedure ()是该event(事件)的操作内容</p>
<h4 id="定时任务操作"><a href="#定时任务操作" class="headerlink" title="定时任务操作"></a>定时任务操作</h4><p>1、查看定期任务</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> event_name,event_definition,interval_value,interval_field,status </span><br><span class="line"><span class="keyword">FROM</span> information_schema.EVENTS;</span><br></pre></td></tr></table></figure>

<p>2、开启或关闭定时任务</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> event run_event <span class="keyword">on</span> completion preserve enable;<span class="operator">/</span><span class="operator">/</span>开启定时任务</span><br><span class="line"><span class="keyword">alter</span> event run_event <span class="keyword">on</span> completion preserve disable;<span class="operator">/</span><span class="operator">/</span>关闭定时任务</span><br></pre></td></tr></table></figure>



<h4 id="定时规则"><a href="#定时规则" class="headerlink" title="定时规则"></a>定时规则</h4><p>1、周期执行–关键字 EVERY 单位有：second、minute、hour、day、week(周)、quarter(季度)、month、year</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">on</span> schedule <span class="keyword">every</span> <span class="number">1</span> week <span class="operator">/</span><span class="operator">/</span>每周执行<span class="number">1</span>次</span><br></pre></td></tr></table></figure>

<p>2、在具体某个时间执行–关键字 AT</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">on</span> schedule <span class="keyword">at</span> <span class="built_in">current_timestamp</span>()<span class="operator">+</span><span class="type">interval</span> <span class="number">5</span> <span class="keyword">day</span> <span class="operator">/</span><span class="operator">/</span><span class="number">5</span>天后执行</span><br><span class="line"><span class="keyword">on</span> schedule <span class="keyword">at</span> <span class="string">&#x27;2019-01-01 00:00:00&#x27;</span> <span class="operator">/</span><span class="operator">/</span>在<span class="number">2019</span>年<span class="number">1</span>月<span class="number">1</span>日，<span class="number">0</span>点整执行</span><br></pre></td></tr></table></figure>

<p>3、在某个时间段执行–关键字STARTS ENDS</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">on</span> schedule <span class="keyword">every</span> <span class="number">1</span> <span class="keyword">day</span> starts <span class="built_in">current_timestamp</span>()<span class="operator">+</span><span class="type">interval</span> <span class="number">5</span> <span class="keyword">day</span> ends <span class="built_in">current_timestamp</span>()<span class="operator">+</span><span class="type">interval</span> <span class="number">1</span> <span class="keyword">month</span> <span class="operator">/</span><span class="operator">/</span><span class="number">5</span>天后开始每天都执行执行到下个月底</span><br><span class="line"><span class="keyword">on</span> schedule <span class="keyword">every</span> <span class="number">1</span> <span class="keyword">day</span> ends <span class="built_in">current_timestamp</span>()<span class="operator">+</span><span class="type">interval</span> <span class="number">5</span> <span class="keyword">day</span> <span class="operator">/</span><span class="operator">/</span>从现在起每天执行，执行<span class="number">5</span>天</span><br></pre></td></tr></table></figure>

<h2 id="三范式"><a href="#三范式" class="headerlink" title="三范式"></a>三范式</h2><p>注：设计只是一种思想一种理念，我们按照规范的设计方式设计数据库对我们来说有好处，但绝对不是说一定要严格遵守，<code>三范式能极大的**减少数据冗余</code>，但是相对编写sql而言是增加了难度的，所以所有好的设计都是要权衡利弊的，要对编码难度，存储大小，执行效率等多方面进行综合考量，但是在学习初期最好紧紧的遵循三范式，在后续的编码中体会和总结自己的经验。</p>
<p>设计数据库表的时候所依据的规范，共三个规范：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一范式：要求有主键，并且要求每一个字段原子性不可再分</span><br><span class="line">第二范式：要求所有非主键字段完全依赖主键，不能产生部分依赖</span><br><span class="line">第三范式：所有非主键字段和主键字段之间不能产生传递依赖</span><br></pre></td></tr></table></figure>

<h4 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h4><p>数据库表中不能出现重复记录，每个字段是原子性的不能再分</p>
<p>不符合第一范式的实例：</p>
<table>
<thead>
<tr>
<th>学生编号</th>
<th>学生姓名</th>
<th>联系方式</th>
</tr>
</thead>
<tbody><tr>
<td>1001</td>
<td>白杰</td>
<td><a href="mailto:&#98;&#x6a;&#64;&#x71;&#x71;&#x2e;&#x63;&#x6f;&#109;">&#98;&#x6a;&#64;&#x71;&#x71;&#x2e;&#x63;&#x6f;&#109;</a>,18565987896</td>
</tr>
<tr>
<td>1002</td>
<td>杨春旺</td>
<td><a href="mailto:&#121;&#99;&#119;&#x40;&#113;&#x71;&#x2e;&#x63;&#x6f;&#x6d;">&#121;&#99;&#119;&#x40;&#113;&#x71;&#x2e;&#x63;&#x6f;&#x6d;</a>,13659874598</td>
</tr>
<tr>
<td>1003</td>
<td>张志伟</td>
<td><a href="mailto:&#122;&#122;&#119;&#x40;&#113;&#x71;&#46;&#x63;&#111;&#x6d;">&#122;&#122;&#119;&#x40;&#113;&#x71;&#46;&#x63;&#111;&#x6d;</a>,12598745698</td>
</tr>
</tbody></table>
<p>解决方案</p>
<table>
<thead>
<tr>
<th>学生编号</th>
<th>学生姓名</th>
<th>邮箱地址</th>
<th>联系电话</th>
</tr>
</thead>
<tbody><tr>
<td>1001</td>
<td>白杰</td>
<td><a href="mailto:&#x62;&#106;&#64;&#113;&#113;&#x2e;&#99;&#x6f;&#109;">&#x62;&#106;&#64;&#113;&#113;&#x2e;&#99;&#x6f;&#109;</a></td>
<td>18565987896</td>
</tr>
<tr>
<td>1002</td>
<td>杨春旺</td>
<td><a href="mailto:&#x79;&#x63;&#119;&#x40;&#x71;&#113;&#x2e;&#99;&#111;&#x6d;">&#x79;&#x63;&#119;&#x40;&#x71;&#113;&#x2e;&#99;&#111;&#x6d;</a></td>
<td>13659874598</td>
</tr>
<tr>
<td>1003</td>
<td>张志伟</td>
<td><a href="mailto:&#122;&#x7a;&#119;&#64;&#x71;&#x71;&#46;&#99;&#x6f;&#109;">&#122;&#x7a;&#119;&#64;&#x71;&#x71;&#46;&#99;&#x6f;&#109;</a></td>
<td>12598745698</td>
</tr>
</tbody></table>
<p>不符合第一范式的实例，不是说他错哈：</p>
<table>
<thead>
<tr>
<th>学生编号</th>
<th>学生姓名</th>
<th>联系地址</th>
</tr>
</thead>
<tbody><tr>
<td>1001</td>
<td>白杰</td>
<td>太原市尖草坪区恒山路108号</td>
</tr>
<tr>
<td>1002</td>
<td>杨春旺</td>
<td>太原市迎泽区迎泽大家100号</td>
</tr>
<tr>
<td>1003</td>
<td>张志伟</td>
<td>太原市杏花岭区北大街152号</td>
</tr>
</tbody></table>
<p>解决方案：</p>
<table>
<thead>
<tr>
<th>学生编号</th>
<th>学生姓名</th>
<th>市</th>
<th>区</th>
<th>详细地址</th>
</tr>
</thead>
<tbody><tr>
<td>1001</td>
<td>白杰</td>
<td>太原市</td>
<td>尖草坪区</td>
<td>恒山路108号</td>
</tr>
<tr>
<td>1002</td>
<td>杨春旺</td>
<td>太原市</td>
<td>迎泽区</td>
<td>迎泽大街100号</td>
</tr>
<tr>
<td>1003</td>
<td>张志伟</td>
<td>太原市</td>
<td>杏花岭区</td>
<td>北大街152号</td>
</tr>
</tbody></table>
<p><strong>必须有主键</strong>，这是数据库设计的最基本要求，主要采用数值型或定长字符串表示，<strong>关于列不可再分，应该根据具体的情况来决定</strong>。如联系方式，为了开发上的便利可能就采用一个字段。</p>
<p>关于第一范式，每一行必须唯一，也就是每个表必须有主键，这是数据库设计的最基本要求，主要采用数值型或定长字符串表示，<strong>关于列不可再分，应该根据具体的情况来决定</strong>。如联系方式，为了开发上的便利可能就采用一个字段。</p>
<h4 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h4><p>第二范式是建立在第一范式基础上的，另外要求所有非主键字段完全依赖主键，不能产生<strong>部分依赖</strong></p>
<p>不符合第二范式的案例：</p>
<p>其中学生编号和课程编号为联合主键</p>
<table>
<thead>
<tr>
<th>学生编号</th>
<th>性别</th>
<th>学生姓名</th>
<th>课程编号</th>
<th>课程名称</th>
<th>教室</th>
<th>成绩</th>
</tr>
</thead>
<tbody><tr>
<td>1001</td>
<td>男</td>
<td>白杰</td>
<td>2001</td>
<td>java</td>
<td>3004</td>
<td>89</td>
</tr>
<tr>
<td>1002</td>
<td>男</td>
<td>杨春旺</td>
<td>2002</td>
<td>mysql</td>
<td>3003</td>
<td>88</td>
</tr>
<tr>
<td>1003</td>
<td>女</td>
<td>刘慧慧</td>
<td>2003</td>
<td>html</td>
<td>3005</td>
<td>90</td>
</tr>
<tr>
<td>1001</td>
<td>男</td>
<td>白杰</td>
<td>2002</td>
<td>mysql</td>
<td>3003</td>
<td>77</td>
</tr>
<tr>
<td>1001</td>
<td>男</td>
<td>白杰</td>
<td>2003</td>
<td>html</td>
<td>3005</td>
<td>89</td>
</tr>
<tr>
<td>1003</td>
<td>女</td>
<td>刘慧慧</td>
<td>2001</td>
<td>java</td>
<td>3004</td>
<td>90</td>
</tr>
</tbody></table>
<p>以上虽然确定了主键，但此表会出现大量的数据冗余，出现冗余的原因在于，学生信息部分依赖了主键的一个字段学生编号，和课程id没有毛线关系。同时课程的信息只是依赖课程id，和学生id没有毛线关系。只有成绩一个字段完全依赖主键的两个部分，这就是第二范式<strong>部分依赖</strong>。</p>
<p><strong>解决方案：</strong></p>
<p>学生表：学生编号为主键</p>
<table>
<thead>
<tr>
<th>学生编号</th>
<th>性别</th>
<th>学生姓名</th>
</tr>
</thead>
<tbody><tr>
<td>1001</td>
<td>男</td>
<td>白杰</td>
</tr>
<tr>
<td>1002</td>
<td>男</td>
<td>杨春旺</td>
</tr>
<tr>
<td>1003</td>
<td>女</td>
<td>刘慧慧</td>
</tr>
</tbody></table>
<p>课程表：课程编号为主键</p>
<table>
<thead>
<tr>
<th>课程编号</th>
<th>课程名称</th>
<th>教室</th>
</tr>
</thead>
<tbody><tr>
<td>2001</td>
<td>java</td>
<td>3003</td>
</tr>
<tr>
<td>2002</td>
<td>mysql</td>
<td>3003</td>
</tr>
<tr>
<td>2003</td>
<td>html</td>
<td>3005</td>
</tr>
</tbody></table>
<p>成绩表：学生编号和课程编号为联合主键</p>
<table>
<thead>
<tr>
<th>学生编号</th>
<th>课程编号</th>
<th>成绩</th>
</tr>
</thead>
<tbody><tr>
<td>1001</td>
<td>2001</td>
<td>89</td>
</tr>
<tr>
<td>1002</td>
<td>2002</td>
<td>88</td>
</tr>
<tr>
<td>1003</td>
<td>2003</td>
<td>90</td>
</tr>
<tr>
<td>1001</td>
<td>2002</td>
<td>77</td>
</tr>
<tr>
<td>1001</td>
<td>2003</td>
<td>89</td>
</tr>
<tr>
<td>1003</td>
<td>2001</td>
<td>90</td>
</tr>
</tbody></table>
<p>如果一个表是单一主键，那么它就是复合第二范式，部分依赖和主键有关系</p>
<p>以上是典型的“多对多”设计</p>
<h4 id="第三范式第三范式"><a href="#第三范式第三范式" class="headerlink" title="第三范式第三范式"></a>第三范式第三范式</h4><p>建立在第二范式基础上的，非主键字段不能传递依赖于主键字段（不要产生传递依赖）</p>
<p>不满足第三范式的例子：</p>
<p>其中学生编号是主键</p>
<table>
<thead>
<tr>
<th>学生编号</th>
<th>学生姓名</th>
<th>专业编号</th>
<th>专业名称</th>
</tr>
</thead>
<tbody><tr>
<td>1001</td>
<td>白杰</td>
<td>2001</td>
<td>计算机</td>
</tr>
<tr>
<td>1002</td>
<td>杨春旺</td>
<td>2002</td>
<td>自动化</td>
</tr>
<tr>
<td>1003</td>
<td>张志伟</td>
<td>2001</td>
<td>计算机</td>
</tr>
</tbody></table>
<p>何为传递依赖？</p>
<p>专业编号依赖学生编号，因为该学生学的就是这个专业啊。但是专业名称和学生其实没多大关系，专业名称依赖于专业编号。这就叫传递依赖，就是某一个字段不直接依赖主键，而是依赖 依赖主键的另一个字段。</p>
<p>解决方法：</p>
<p>学生表，学生编号为主键：</p>
<p>学生编号为主键：</p>
<table>
<thead>
<tr>
<th>学生编号</th>
<th>学生姓名</th>
<th>专业编号</th>
</tr>
</thead>
<tbody><tr>
<td>1001</td>
<td>白杰</td>
<td>2001</td>
</tr>
<tr>
<td>1002</td>
<td>杨春旺</td>
<td>2002</td>
</tr>
<tr>
<td>1003</td>
<td>张志伟</td>
<td>2001</td>
</tr>
</tbody></table>
<p>专业表，专业编号为主键：</p>
<table>
<thead>
<tr>
<th>专业编号</th>
<th>专业名称</th>
</tr>
</thead>
<tbody><tr>
<td>2001</td>
<td>计算机</td>
</tr>
<tr>
<td>2002</td>
<td>自动化</td>
</tr>
</tbody></table>
<p>以上设计是典型的一对多的设计，一存储在一张表中，多存储在一张表中，<strong>在多的那张表中添加外键指向一的一方</strong>。</p>
<h3 id="常见表关系"><a href="#常见表关系" class="headerlink" title="常见表关系"></a>常见表关系</h3><h4 id="一对一-用的不多"><a href="#一对一-用的不多" class="headerlink" title="一对一 用的不多"></a>一对一 用的不多</h4><p>一个表和另一张表存在的关系是一对一，此种设计不常用，因为此种关系经常会将多张表合并为一张表。</p>
<p>举例：</p>
<p>学生信息表可以分为基本信息表和详细信息表。</p>
<p>可能有这种需求，需要给个某个账户对学生表的操作，但是有些私密信息又不能暴露，就可以拆分。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一种方案：分两张表存储，共享主键</span><br><span class="line">第二种方案：分两张表存储，外键唯一</span><br></pre></td></tr></table></figure>

<h4 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h4><p>第三范式的例子</p>
<p>两张表 外键建在多的一方</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">分两张表存储，在多的一方添加外键，</span><br><span class="line">这个外键字段引用一的一方中的主键字段</span><br></pre></td></tr></table></figure>

<h4 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h4><p>第二范式的例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">分三张表存储，在学生表中存储学生信息，在课程表中存储课程信息，</span><br><span class="line">在成绩表中存储学生和课程的关系信息</span><br></pre></td></tr></table></figure>



<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><ol>
<li>事务四大提醒ACID<ul>
<li>原子性： 要么都成功要么都失败</li>
<li>一致性： 执行前后状态必须是一致的，比如转账</li>
<li>隔离性： 事务之间不会相互影响。由锁机制和MVCC机制来实现</li>
<li>持久性： 事务成功必须写入磁盘</li>
</ul>
</li>
<li>4个特性与WAL 有关系</li>
</ol>
<p>​		<a target="_blank" rel="noopener" href="https://www.cnblogs.com/xuwc/p/14037750.html">预写日志(WAL)介绍 - xuwc - 博客园 (cnblogs.com)</a></p>
<p>​		WAL(Write Ahead Log)预写日志</p>
<ul>
<li>原子性: 事务的原子性是通过Redo Log和Undo Log保证的。<ul>
<li>每一个写事务，都会修改BufferPool，从而产生相应的Redo&#x2F;Undo日志，这些日志信息会被记录<br>到日志文件中。在 MySOL 中，任何 Buffer Pool中的页被刷到磁盘之前，都会先写入到日志文件中,<br>如果Buffer Pool 中的数据提交(commit)，此时数据库挂了，那在数据库再次启动之后，可以通<br>Redo志将其恢复出来，以保证脏页写的数据不会丢失。如果数据没有提交（没有commit)，此时数<br>据库挂了,就需要通过Undo来实现了。</li>
</ul>
</li>
<li>持久性：如何实现<ul>
<li>通过Redo Log 和WAL实现的。</li>
</ul>
</li>
</ul>
<h3 id="等值连接-与-非等值连接"><a href="#等值连接-与-非等值连接" class="headerlink" title="等值连接 与 非等值连接"></a>等值连接 与 非等值连接</h3><p><img src="/2022/09/01/mysql/image-20220321202239838.png" alt="image-20220321202239838"></p>
<h2 id="逻辑架构"><a href="#逻辑架构" class="headerlink" title="逻辑架构"></a>逻辑架构</h2><h2 id="InnoDB数据存储结构"><a href="#InnoDB数据存储结构" class="headerlink" title="InnoDB数据存储结构"></a>InnoDB数据存储结构</h2><h2 id="索引的创建与设计原则"><a href="#索引的创建与设计原则" class="headerlink" title="索引的创建与设计原则"></a>索引的创建与设计原则</h2><h2 id="性能分析工具的使用"><a href="#性能分析工具的使用" class="headerlink" title="性能分析工具的使用"></a>性能分析工具的使用</h2><h2 id="索引优化与查询优化"><a href="#索引优化与查询优化" class="headerlink" title="索引优化与查询优化"></a>索引优化与查询优化</h2><h2 id="数据库的设计闺房"><a href="#数据库的设计闺房" class="headerlink" title="数据库的设计闺房"></a>数据库的设计闺房</h2><h2 id="数据库的其它调优测率"><a href="#数据库的其它调优测率" class="headerlink" title="数据库的其它调优测率"></a>数据库的其它调优测率</h2><h2 id="事务基础知识"><a href="#事务基础知识" class="headerlink" title="事务基础知识"></a>事务基础知识</h2><h2 id="Mysql事务日志"><a href="#Mysql事务日志" class="headerlink" title="Mysql事务日志"></a>Mysql事务日志</h2><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h2 id="多版本并发控制"><a href="#多版本并发控制" class="headerlink" title="多版本并发控制"></a>多版本并发控制</h2><h2 id="其它数据库日志"><a href="#其它数据库日志" class="headerlink" title="其它数据库日志"></a>其它数据库日志</h2><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">CodeZhong</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://zibizhong.github.io/2022/09/01/mysql/">http://zibizhong.github.io/2022/09/01/mysql/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://zibizhong.github.io" target="_blank">CodeZhongBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/images/background.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://fastly.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/09/01/%E8%8B%A5%E4%BE%9D/"><img class="prev-cover" src="/images/background.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">若依</div></div></a></div><div class="next-post pull-right"><a href="/2022/08/30/Dubbo/"><img class="next-cover" src="/images/background.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Dubbo</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Mysql%E7%AC%94%E8%AE%B0"><span class="toc-number">1.</span> <span class="toc-text">Mysql笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Mysql%E6%9E%B6%E6%9E%84"><span class="toc-number">1.1.</span> <span class="toc-text">Mysql架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%86%E8%A7%A3mysql%E7%9A%84%E5%AE%89%E8%A3%85%E7%9B%AE%E5%BD%95"><span class="toc-number">1.1.1.</span> <span class="toc-text">了解mysql的安装目录</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#windows%E4%B8%AD%E7%9A%84%E7%9B%AE%E5%BD%95"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">windows中的目录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#linux%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">linux中的文件目录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">常用配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mysql%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E7%9A%84%E6%96%B9%E6%B3%95mysql%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.1.4.</span> <span class="toc-text">mysql修改配置的方法mysql修改配置的方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mysql%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84"><span class="toc-number">1.1.2.</span> <span class="toc-text">mysql的系统架构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">1、 数据库和数据库实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MySQL%E6%9E%B6%E6%9E%84"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">MySQL架构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mysql%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">1.1.3.</span> <span class="toc-text">mysql的存储引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E5%B8%B8%E7%94%A8%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%8F%8A%E7%89%B9%E7%82%B9"><span class="toc-number">1.1.4.</span> <span class="toc-text">MySQL常用存储引擎及特点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">InnoDB存储引擎</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MyISAM%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">MyISAM存储引擎</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E5%BC%95%E6%93%8E%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">1.1.4.3.</span> <span class="toc-text">两种引擎的对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">1.1.4.4.</span> <span class="toc-text">选择合适的存储引擎</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mysql%E7%B4%A2%E5%BC%95"><span class="toc-number">1.2.</span> <span class="toc-text">Mysql索引</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E7%9B%98%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.0.1.</span> <span class="toc-text">计算机硬盘原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A3%81%E7%9B%98IO%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.0.1.1.</span> <span class="toc-text">磁盘IO的问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E7%9A%84%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5"><span class="toc-number">1.2.0.1.2.</span> <span class="toc-text">磁盘的一些概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E5%AE%B9%E9%87%8F%E8%AE%A1%E7%AE%97"><span class="toc-number">1.2.0.1.3.</span> <span class="toc-text">磁盘容量计算</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E8%AF%BB%E5%8F%96%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4"><span class="toc-number">1.2.0.1.4.</span> <span class="toc-text">磁盘读取响应时间</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9D%97-x2F-%E7%B0%87"><span class="toc-number">1.2.0.1.5.</span> <span class="toc-text">块&#x2F;簇</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#page"><span class="toc-number">1.2.0.1.6.</span> <span class="toc-text">page</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%87%E5%8C%BA%E3%80%81%E5%9D%97-x2F-%E7%B0%87%E3%80%81page%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.2.0.1.7.</span> <span class="toc-text">扇区、块&#x2F;簇、page的关系</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A8%8B"><span class="toc-number">1.2.0.1.8.</span> <span class="toc-text">计算机读取数据流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86%E4%B8%8E%E7%A3%81%E7%9B%98%E9%A2%84%E8%AF%BB"><span class="toc-number">1.2.0.1.9.</span> <span class="toc-text">局部性原理与磁盘预读</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mysql%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E9%80%89%E5%9E%8B"><span class="toc-number">1.2.0.2.</span> <span class="toc-text">mysql数据结构的选型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8"><span class="toc-number">1.2.0.2.1.</span> <span class="toc-text">数组和链表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#hash"><span class="toc-number">1.2.0.2.2.</span> <span class="toc-text">hash</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%91"><span class="toc-number">1.2.0.2.3.</span> <span class="toc-text">树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B-%E6%A0%91"><span class="toc-number">1.2.0.2.4.</span> <span class="toc-text">B-树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B-%E6%A0%91-1"><span class="toc-number">1.2.0.2.5.</span> <span class="toc-text">B+ 树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-B-%E6%A0%91"><span class="toc-number">1.2.0.2.6.</span> <span class="toc-text">为什么使用 B+树</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95"><span class="toc-number">1.2.0.3.</span> <span class="toc-text">为什么要使用索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.0.4.</span> <span class="toc-text">索引的数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1"><span class="toc-number">1.2.0.4.1.</span> <span class="toc-text">索引的数据结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%89%E4%BA%86%E7%B4%A2%E5%BC%95%E6%80%8E%E4%B9%88%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.2.0.4.2.</span> <span class="toc-text">有了索引怎么查询</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%86%E7%B1%BB%E5%92%8C%E5%88%9B%E5%BB%BA"><span class="toc-number">1.2.0.5.</span> <span class="toc-text">索引的分类和创建</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="toc-number">1.2.0.5.1.</span> <span class="toc-text">聚簇索引和非聚簇索引</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E5%8A%BF%EF%BC%9A"><span class="toc-number">1.2.0.5.1.1.</span> <span class="toc-text">使用聚簇索引的优势：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%BB%E9%94%AE%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8%E8%87%AA%E5%A2%9Eid"><span class="toc-number">1.2.0.5.1.2.</span> <span class="toc-text">主键建议使用自增id</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95-%EF%BC%88primary-key%EF%BC%89"><span class="toc-number">1.2.0.5.2.</span> <span class="toc-text">主键索引 （primary key）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95-%EF%BC%88%E5%B8%B8%E8%A7%84%E7%B4%A2%E5%BC%95%EF%BC%89-normal"><span class="toc-number">1.2.0.5.3.</span> <span class="toc-text">普通索引 （常规索引）(normal)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%EF%BC%88UNIQUE-%EF%BC%89"><span class="toc-number">1.2.0.5.4.</span> <span class="toc-text">唯一索引（UNIQUE ）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95%EF%BC%88FULLTEXT%EF%BC%89"><span class="toc-number">1.2.0.5.5.</span> <span class="toc-text">全文索引（FULLTEXT）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E7%B4%A2%E5%BC%95%EF%BC%88SPATIAL%EF%BC%89"><span class="toc-number">1.2.0.5.6.</span> <span class="toc-text">空间索引（SPATIAL）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E7%B4%A2%E5%BC%95%EF%BC%88%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%EF%BC%89%E9%87%8D%E8%A6%81"><span class="toc-number">1.2.0.5.7.</span> <span class="toc-text">复合索引（联合索引）重要</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#hash%E7%B4%A2%E5%BC%95"><span class="toc-number">1.2.0.5.8.</span> <span class="toc-text">hash索引</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#navicat%E4%B8%AD%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">1.2.0.6.</span> <span class="toc-text">navicat中创建索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.0.7.</span> <span class="toc-text">使用索引的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">1.2.0.7.1.</span> <span class="toc-text">创建索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B9%A0%E6%83%AF%E4%BD%BF%E7%94%A8%E5%A4%8D%E5%90%88%E7%B4%A2%E5%BC%95"><span class="toc-number">1.2.0.7.2.</span> <span class="toc-text">习惯使用复合索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E4%B8%8D%E4%BC%9A%E5%8C%85%E5%90%AB%E6%9C%89NULL%E5%80%BC%E7%9A%84%E5%88%97"><span class="toc-number">1.2.0.7.3.</span> <span class="toc-text">索引不会包含有NULL值的列</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%9F%AD%E7%B4%A2%E5%BC%95"><span class="toc-number">1.2.0.7.4.</span> <span class="toc-text">使用短索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%9A%84%E7%B4%A2%E5%BC%95%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.0.7.5.</span> <span class="toc-text">排序的索引问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#MySQL%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5"><span class="toc-number">1.2.0.7.6.</span> <span class="toc-text">MySQL索引失效的几种情况</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#MySQL%E4%B8%BB%E8%A6%81%E6%8F%90%E4%BE%9B2%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%9A%84%E7%B4%A2%E5%BC%95%EF%BC%9AB-Tree%E7%B4%A2%E5%BC%95%EF%BC%8CHash%E7%B4%A2%E5%BC%95"><span class="toc-number">1.2.0.7.7.</span> <span class="toc-text">MySQL主要提供2种方式的索引：B-Tree索引，Hash索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%9B%9E%E7%AD%94%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.0.7.8.</span> <span class="toc-text">面试回答问题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#explain%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.2.0.8.</span> <span class="toc-text">explain关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#explain%E7%9A%84%E7%94%A8%E9%80%94"><span class="toc-number">1.2.0.8.1.</span> <span class="toc-text">explain的用途</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#explain%E7%9A%84%E6%89%A7%E8%A1%8C%E6%95%88%E6%9E%9C"><span class="toc-number">1.2.0.8.2.</span> <span class="toc-text">explain的执行效果</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#explain%E5%8C%85%E5%90%AB%E7%9A%84%E5%AD%97%E6%AE%B5"><span class="toc-number">1.2.0.8.3.</span> <span class="toc-text">explain包含的字段</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#id%E5%AD%97%E6%AE%B5"><span class="toc-number">1.2.0.8.3.1.</span> <span class="toc-text">id字段</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#select-type%E5%AD%97%E6%AE%B5"><span class="toc-number">1.2.0.8.3.2.</span> <span class="toc-text">select_type字段</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#type%E5%AD%97%E6%AE%B5"><span class="toc-number">1.2.0.8.3.3.</span> <span class="toc-text">type字段</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#table%E5%AD%97%E6%AE%B5"><span class="toc-number">1.2.0.8.3.4.</span> <span class="toc-text">table字段</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#possible-keys%E5%AD%97%E6%AE%B5"><span class="toc-number">1.2.0.8.3.5.</span> <span class="toc-text">possible_keys字段</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#key%E5%AD%97%E6%AE%B5"><span class="toc-number">1.2.0.8.3.6.</span> <span class="toc-text">key字段</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#key-len%E5%AD%97%E6%AE%B5"><span class="toc-number">1.2.0.8.3.7.</span> <span class="toc-text">key_len字段</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#ref%E5%AD%97%E6%AE%B5"><span class="toc-number">1.2.0.8.3.8.</span> <span class="toc-text">ref字段</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#rows%E5%AD%97%E6%AE%B5"><span class="toc-number">1.2.0.8.3.9.</span> <span class="toc-text">rows字段</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#partitions%E5%AD%97%E6%AE%B5"><span class="toc-number">1.2.0.8.3.10.</span> <span class="toc-text">partitions字段</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#filtered%E5%AD%97%E6%AE%B5"><span class="toc-number">1.2.0.8.3.11.</span> <span class="toc-text">filtered字段</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Extra%E5%AD%97%E6%AE%B5"><span class="toc-number">1.2.0.8.3.12.</span> <span class="toc-text">Extra字段</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mysql%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.3.</span> <span class="toc-text">Mysql事务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%AE%80%E4%BB%8B"><span class="toc-number">1.3.0.1.</span> <span class="toc-text">事务简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%9B%9B%E5%A4%A7%E7%89%B9%E5%BE%81"><span class="toc-number">1.3.0.2.</span> <span class="toc-text">事务四大特征</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%88Atomicity%EF%BC%89"><span class="toc-number">1.3.0.2.1.</span> <span class="toc-text">原子性（Atomicity）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%88Consistency%EF%BC%89"><span class="toc-number">1.3.0.2.2.</span> <span class="toc-text">一致性（Consistency）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9A%94%E7%A6%BB%E6%80%A7%EF%BC%88Isolation%EF%BC%89"><span class="toc-number">1.3.0.2.3.</span> <span class="toc-text">隔离性（Isolation）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E6%80%A7%EF%BC%88Durability%EF%BC%89"><span class="toc-number">1.3.0.2.4.</span> <span class="toc-text">持久性（Durability）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E6%8F%90%E4%BA%A4%E3%80%81%E5%9B%9E%E6%BB%9A"><span class="toc-number">1.3.0.3.</span> <span class="toc-text">事务提交、回滚</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%89%B9%E6%80%A7%E2%80%93%E9%9A%94%E7%A6%BB%E6%80%A7"><span class="toc-number">1.3.0.4.</span> <span class="toc-text">事务特性–隔离性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9A%94%E7%A6%BB%E6%80%A7%E6%9C%89%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">1.3.0.4.1.</span> <span class="toc-text">隔离性有隔离级别</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%AF%BB%E6%9C%AA%E6%8F%90%E4%BA%A4"><span class="toc-number">1.3.0.4.1.1.</span> <span class="toc-text">读未提交</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%AF%BB%E5%B7%B2%E6%8F%90%E4%BA%A4"><span class="toc-number">1.3.0.4.1.2.</span> <span class="toc-text">读已提交</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB"><span class="toc-number">1.3.0.4.1.3.</span> <span class="toc-text">可重复读</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%B2%E8%A1%8C%E5%8C%96"><span class="toc-number">1.3.0.4.2.</span> <span class="toc-text">串行化</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mysql%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6"><span class="toc-number">1.4.</span> <span class="toc-text">Mysql的锁机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#InnoDB%E8%A1%8C%E9%94%81%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="toc-number">1.4.0.1.</span> <span class="toc-text">InnoDB行锁的种类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E9%94%81%EF%BC%88Record-Lock%EF%BC%89"><span class="toc-number">1.4.0.1.1.</span> <span class="toc-text">记录锁（Record Lock）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%B4%E9%9A%99%E9%94%81%EF%BC%88GAP-Lock%EF%BC%89"><span class="toc-number">1.4.0.1.2.</span> <span class="toc-text">间隙锁（GAP Lock）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E9%94%81%E5%92%8C%E9%97%B4%E9%9A%99%E9%94%81%E7%9A%84%E7%BB%84%E5%90%88%EF%BC%88next-key-lock%EF%BC%89"><span class="toc-number">1.4.0.1.3.</span> <span class="toc-text">记录锁和间隙锁的组合（next-key lock）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A1%A8%E9%94%81"><span class="toc-number">1.4.0.1.4.</span> <span class="toc-text">表锁</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#InnoDB%E7%9A%84%E9%94%81%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.0.2.</span> <span class="toc-text">InnoDB的锁类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%BB%E9%94%81"><span class="toc-number">1.4.0.2.1.</span> <span class="toc-text">读锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%99%E9%94%81"><span class="toc-number">1.4.0.2.2.</span> <span class="toc-text">写锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#MDL%E9%94%81"><span class="toc-number">1.4.0.2.3.</span> <span class="toc-text">MDL锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%84%8F%E5%90%91%E9%94%81"><span class="toc-number">1.4.0.2.4.</span> <span class="toc-text">意向锁</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E5%8F%A6%E4%B8%80%E4%B8%AA%E8%A7%92%E5%BA%A6%E5%8C%BA%E5%88%86%E9%94%81%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.4.0.3.</span> <span class="toc-text">从另一个角度区分锁的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-number">1.4.0.3.1.</span> <span class="toc-text">乐观锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">1.4.0.3.2.</span> <span class="toc-text">悲观锁</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81%E7%AD%89%E5%BE%85%E5%92%8C%E6%AD%BB%E9%94%81"><span class="toc-number">1.4.0.4.</span> <span class="toc-text">锁等待和死锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="toc-number">1.4.0.5.</span> <span class="toc-text">如何避免死锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MVCC%EF%BC%8C%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="toc-number">1.4.0.6.</span> <span class="toc-text">MVCC，多版本并发控制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BD%93%E5%89%8D%E8%AF%BB%E5%92%8C%E5%BF%AB%E7%85%A7%E8%AF%BB%EF%BC%9F"><span class="toc-number">1.4.0.6.1.</span> <span class="toc-text">什么是当前读和快照读？</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BD%93%E5%89%8D%E8%AF%BB%EF%BC%8C%E5%BF%AB%E7%85%A7%E8%AF%BB%E5%92%8CMVCC%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.4.0.6.1.1.</span> <span class="toc-text">当前读，快照读和MVCC的关系</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#MVCC%E8%83%BD%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-number">1.4.0.6.1.2.</span> <span class="toc-text">MVCC能解决什么问题</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#MVCC%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.4.0.6.1.3.</span> <span class="toc-text">MVCC的实现原理</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Read-View-%E8%AF%BB%E8%A7%86%E5%9B%BE"><span class="toc-number">1.4.0.6.1.4.</span> <span class="toc-text">Read View(读视图)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redo-log"><span class="toc-number">1.4.0.7.</span> <span class="toc-text">Redo log</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Redo-log%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.4.0.7.1.</span> <span class="toc-text">Redo log工作原理</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mysql%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5"><span class="toc-number">1.5.</span> <span class="toc-text">Mysql主从同步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.5.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90"><span class="toc-number">1.5.2.</span> <span class="toc-text">主从复制工作原理剖析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8mysql-%E7%9A%84%E4%B8%BB%E4%BB%8E"><span class="toc-number">1.5.3.</span> <span class="toc-text">为什么要用mysql 的主从</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">实现服务器负载均衡</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%A4%8D%E5%88%B6%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%9A%84%E5%BC%82%E5%9C%B0%E5%A4%87%E4%BB%BD"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">通过复制实现数据的异地备份</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%90%E9%AB%98%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%AF%E7%94%A8%E6%80%A7"><span class="toc-number">1.5.3.3.</span> <span class="toc-text">提高数据库系统的可用性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E9%85%8D%E7%BD%AEmysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">1.5.4.</span> <span class="toc-text">怎么配置mysql主从复制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%87%86%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">环境准环境准备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE"><span class="toc-number">1.5.4.2.</span> <span class="toc-text">配置文件配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#master%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E5%88%9B%E5%BB%BA%E5%A4%8D%E5%88%B6%E7%94%A8%E6%88%B7%E5%B9%B6%E6%8E%88%E6%9D%83"><span class="toc-number">1.5.4.3.</span> <span class="toc-text">master数据库，创建复制用户并授权</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%83%BD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%AF%E8%83%BD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.5.5.</span> <span class="toc-text">可能遇到的问题可能遇到的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%B0%E8%B1%A1%E7%8E%B0%E8%B1%A1"><span class="toc-number">1.5.5.1.</span> <span class="toc-text">现象现象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E5%9B%A0"><span class="toc-number">1.5.5.1.1.</span> <span class="toc-text">原因</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3"><span class="toc-number">1.5.5.1.2.</span> <span class="toc-text">解决</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E5%87%BD%E6%95%B0"><span class="toc-number">1.6.</span> <span class="toc-text">存储过程和函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-number">1.6.1.</span> <span class="toc-text">触发器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E5%99%A8%E7%9A%84%E7%89%B9%E6%80%A7%E8%A7%A6%E5%8F%91%E5%99%A8%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">触发器的特性触发器的特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E5%99%A8%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">1.6.1.2.</span> <span class="toc-text">触发器的创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E8%A7%A6%E5%8F%91%E5%99%A8%E5%88%A0%E9%99%A4%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-number">1.6.1.3.</span> <span class="toc-text">删除触发器删除触发器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">1.6.2.</span> <span class="toc-text">存储过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">变量</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%8F%98%E9%87%8F"><span class="toc-number">1.6.2.1.1.</span> <span class="toc-text">系统变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E5%8F%98%E9%87%8F%E7%94%A8%E6%88%B7%E5%8F%98%E9%87%8F"><span class="toc-number">1.6.2.1.2.</span> <span class="toc-text">用户变量用户变量</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">存储过程的创建存储过程的创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.6.2.3.</span> <span class="toc-text">流程控制语句</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%87%BD%E6%95%B0"><span class="toc-number">1.6.3.</span> <span class="toc-text">存储函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%87%BD%E6%95%B0"><span class="toc-number">1.6.3.1.</span> <span class="toc-text">创建函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">1.6.3.2.</span> <span class="toc-text">使用函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%87%BD%E6%95%B0"><span class="toc-number">1.6.3.3.</span> <span class="toc-text">查看函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%87%BD%E6%95%B0"><span class="toc-number">1.6.3.4.</span> <span class="toc-text">删除函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1"><span class="toc-number">1.6.3.5.</span> <span class="toc-text">定时任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%AE%9A%E6%97%B6%E7%AD%96%E7%95%A5%E6%98%AF%E5%90%A6%E5%BC%80%E5%90%AF"><span class="toc-number">1.6.3.6.</span> <span class="toc-text">查看定时策略是否开启</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%88%9B%E5%BB%BA%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1"><span class="toc-number">1.6.3.7.</span> <span class="toc-text">创建定时任务创建定时任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E6%93%8D%E4%BD%9C"><span class="toc-number">1.6.3.8.</span> <span class="toc-text">定时任务操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E8%A7%84%E5%88%99"><span class="toc-number">1.6.3.9.</span> <span class="toc-text">定时规则</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E8%8C%83%E5%BC%8F"><span class="toc-number">1.7.</span> <span class="toc-text">三范式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E8%8C%83%E5%BC%8F"><span class="toc-number">1.7.0.1.</span> <span class="toc-text">第一范式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E8%8C%83%E5%BC%8F"><span class="toc-number">1.7.0.2.</span> <span class="toc-text">第二范式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E8%8C%83%E5%BC%8F%E7%AC%AC%E4%B8%89%E8%8C%83%E5%BC%8F"><span class="toc-number">1.7.0.3.</span> <span class="toc-text">第三范式第三范式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E8%A1%A8%E5%85%B3%E7%B3%BB"><span class="toc-number">1.7.1.</span> <span class="toc-text">常见表关系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E5%AF%B9%E4%B8%80-%E7%94%A8%E7%9A%84%E4%B8%8D%E5%A4%9A"><span class="toc-number">1.7.1.1.</span> <span class="toc-text">一对一 用的不多</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E5%AF%B9%E5%A4%9A"><span class="toc-number">1.7.1.2.</span> <span class="toc-text">一对多</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E5%AF%B9%E5%A4%9A"><span class="toc-number">1.7.1.3.</span> <span class="toc-text">多对多</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">1.8.</span> <span class="toc-text">面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%89%E5%80%BC%E8%BF%9E%E6%8E%A5-%E4%B8%8E-%E9%9D%9E%E7%AD%89%E5%80%BC%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.8.1.</span> <span class="toc-text">等值连接 与 非等值连接</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84"><span class="toc-number">1.9.</span> <span class="toc-text">逻辑架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.10.</span> <span class="toc-text">InnoDB数据存储结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">1.11.</span> <span class="toc-text">索引的创建与设计原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.12.</span> <span class="toc-text">性能分析工具的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E4%B8%8E%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="toc-number">1.13.</span> <span class="toc-text">索引优化与查询优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AE%BE%E8%AE%A1%E9%97%BA%E6%88%BF"><span class="toc-number">1.14.</span> <span class="toc-text">数据库的设计闺房</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%85%B6%E5%AE%83%E8%B0%83%E4%BC%98%E6%B5%8B%E7%8E%87"><span class="toc-number">1.15.</span> <span class="toc-text">数据库的其它调优测率</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.16.</span> <span class="toc-text">事务基础知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mysql%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97"><span class="toc-number">1.17.</span> <span class="toc-text">Mysql事务日志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81"><span class="toc-number">1.18.</span> <span class="toc-text">锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="toc-number">1.19.</span> <span class="toc-text">多版本并发控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E5%AE%83%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%A5%E5%BF%97"><span class="toc-number">1.20.</span> <span class="toc-text">其它数据库日志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">1.21.</span> <span class="toc-text">主从复制</span></a></li></ol></li></ol></div></div><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/headImg.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">CodeZhong</div><div class="author-info__description"></div></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/zibizhong" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/2385172737@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">微信公众号: 自闭钟同学</div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 By CodeZhong</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/chenxz21/hexo-theme-bcxm">Bcxm</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://fastly.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script type="text/javascript" src="https://fastly.jsdelivr.net/npm/leancloud-storage@4.10.0/dist/av-min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://fastly.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://fastly.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>